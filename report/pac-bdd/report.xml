<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="20" skipped="0" tests="39" time="43.886" timestamp="2026-01-08T22:35:04.833254+01:00" hostname="gpd"><testcase classname="test_fixture" name="test_dummy_fixture" time="0.001" /><testcase classname="test_fixture" name="test_dummy_async_fixture" time="0.002" /><testcase classname="test_openapi" name="test_swagger_flow_service" time="0.001"><failure message="NotImplementedError: swagger compliance non testé">def test_swagger_flow_service():
        url = '???'
&gt;       _test_swagger(
            url,
            "docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE A - PR XP Z12-013 - AFNOR-Flow_Service-1.1.0-swagger.json",
        )

test_openapi.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

url = '???', swagger = 'docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE A - PR XP Z12-013 - AFNOR-Flow_Service-1.1.0-swagger.json'

    def _test_swagger(url: str, swagger: str):
        """
            Vérifier si une API respecte une definition Swagger/OpenAPI
    
        Cette API doit respecter le versioning indiqué dans l’URL de la route API du Swagger. Dans un objectif de
        simplification le versioning des routes n’est pas affiché dans le présent document;
        Dans cette API publiée par le Fournisseur API ce dernier peut :
        •Avoir une URL spécifique en amont du versioning
        •Ajouter des propriétés aux objets dans les requêtes.
        •Ajouter des paramètres aux routes dans les requêtes.
        •Ajouter des propriétés aux objets dans les réponses.
        •Ajouter des codes erreurs dans les réponses.
        """
&gt;       raise NotImplementedError("swagger compliance non testé")
E       NotImplementedError: swagger compliance non testé

test_openapi.py:14: NotImplementedError</failure></testcase><testcase classname="test_openapi" name="test_swagger_directory_service" time="0.000"><failure message="NotImplementedError: swagger compliance non testé">def test_swagger_directory_service():
        url = "???"
&gt;       _test_swagger(
            url,
            "docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE B - PR XP Z12-013 - AFNOR-Directory_Service-1.1.0-swagger.json",
        )

test_openapi.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

url = '???', swagger = 'docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE B - PR XP Z12-013 - AFNOR-Directory_Service-1.1.0-swagger.json'

    def _test_swagger(url: str, swagger: str):
        """
            Vérifier si une API respecte une definition Swagger/OpenAPI
    
        Cette API doit respecter le versioning indiqué dans l’URL de la route API du Swagger. Dans un objectif de
        simplification le versioning des routes n’est pas affiché dans le présent document;
        Dans cette API publiée par le Fournisseur API ce dernier peut :
        •Avoir une URL spécifique en amont du versioning
        •Ajouter des propriétés aux objets dans les requêtes.
        •Ajouter des paramètres aux routes dans les requêtes.
        •Ajouter des propriétés aux objets dans les réponses.
        •Ajouter des codes erreurs dans les réponses.
        """
&gt;       raise NotImplementedError("swagger compliance non testé")
E       NotImplementedError: swagger compliance non testé

test_openapi.py:14: NotImplementedError</failure></testcase><testcase classname="test_pac0" name="test_pac0_import_services" time="0.008"><failure message="AttributeError(&quot;'FastAPI' object has no attribute 'run'&quot;) [single exception in ExceptionGroup]">+ Exception Group Traceback (most recent call last):
  |   File "/home/philippe/src/PA_Communautaire/packages/pac-bdd/test_pac0.py", line 17, in test_pac0_import_services
  |     async with asyncio.TaskGroup() as tg:
  |                ~~~~~~~~~~~~~~~~~^^
  |   File "/home/philippe/.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/taskgroups.py", line 71, in __aexit__
  |     return await self._aexit(et, exc)
  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/home/philippe/.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/taskgroups.py", line 173, in _aexit
  |     raise BaseExceptionGroup(
  |     ...&lt;2 lines&gt;...
  |     ) from None
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "/home/philippe/src/PA_Communautaire/packages/pac-bdd/test_pac0.py", line 18, in test_pac0_import_services
    |     task1 = tg.create_task(api_gateway_main.app.run())
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
    | AttributeError: 'FastAPI' object has no attribute 'run'
    +------------------------------------</failure></testcase><testcase classname="test_scenario" name="test_trackingid_fourni" time="8.414"><failure message="httpx.ReadTimeout: timed out">@contextlib.contextmanager
    def map_httpcore_exceptions() -&gt; typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
&gt;           yield

.venv/lib/python3.13/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
.venv/lib/python3.13/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
.venv/lib/python3.13/site-packages/httpcore/_sync/connection.py:103: in handle_request
    return self._connection.handle_request(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:136: in handle_request
    raise exc
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:106: in handle_request
    ) = self._receive_response_headers(**kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:177: in _receive_response_headers
    event = self._receive_event(timeout=timeout)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:217: in _receive_event
    data = self._network_stream.read(
.venv/lib/python3.13/site-packages/httpcore/_backends/sync.py:126: in read
    with map_exceptions(exc_map):
         ^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

map = {&lt;class 'TimeoutError'&gt;: &lt;class 'httpcore.ReadTimeout'&gt;, &lt;class 'OSError'&gt;: &lt;class 'httpcore.ReadError'&gt;}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -&gt; typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
&gt;                   raise to_exc(exc) from exc
E                   httpcore.ReadTimeout: timed out

.venv/lib/python3.13/site-packages/httpcore/_exceptions.py:14: ReadTimeout

The above exception was the direct cause of the following exception:

fixturefunc = &lt;function api_call at 0x7886aee607c0&gt;, request = &lt;FixtureRequest for &lt;Function test_trackingid_fourni&gt;&gt;
kwargs = {'path': '/flows', 'verb': 'POST', 'world1pac': &lt;pac0.shared.test.fixture.WorldContext object at 0x7886aedac050&gt;}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/pac_bdd/api.py:33: in api_call
    response = httpx.get(world1pac.pac1.api_base_url)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_api.py:195: in get
    return request(
.venv/lib/python3.13/site-packages/httpx/_api.py:109: in request
    return client.request(
.venv/lib/python3.13/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
.venv/lib/python3.13/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
.venv/lib/python3.13/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @contextlib.contextmanager
    def map_httpcore_exceptions() -&gt; typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
&gt;           raise mapped_exc(message) from exc
E           httpx.ReadTimeout: timed out

.venv/lib/python3.13/site-packages/httpx/_transports/default.py:118: ReadTimeout</failure></testcase><testcase classname="test_scenario" name="test_trackingid_absent" time="8.374"><failure message="httpx.ReadTimeout: timed out">@contextlib.contextmanager
    def map_httpcore_exceptions() -&gt; typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
&gt;           yield

.venv/lib/python3.13/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
.venv/lib/python3.13/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
.venv/lib/python3.13/site-packages/httpcore/_sync/connection.py:103: in handle_request
    return self._connection.handle_request(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:136: in handle_request
    raise exc
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:106: in handle_request
    ) = self._receive_response_headers(**kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:177: in _receive_response_headers
    event = self._receive_event(timeout=timeout)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:217: in _receive_event
    data = self._network_stream.read(
.venv/lib/python3.13/site-packages/httpcore/_backends/sync.py:126: in read
    with map_exceptions(exc_map):
         ^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

map = {&lt;class 'TimeoutError'&gt;: &lt;class 'httpcore.ReadTimeout'&gt;, &lt;class 'OSError'&gt;: &lt;class 'httpcore.ReadError'&gt;}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -&gt; typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
&gt;                   raise to_exc(exc) from exc
E                   httpcore.ReadTimeout: timed out

.venv/lib/python3.13/site-packages/httpcore/_exceptions.py:14: ReadTimeout

The above exception was the direct cause of the following exception:

fixturefunc = &lt;function api_call at 0x7886aee607c0&gt;, request = &lt;FixtureRequest for &lt;Function test_trackingid_absent&gt;&gt;
kwargs = {'path': '/flows', 'verb': 'POST', 'world1pac': &lt;pac0.shared.test.fixture.WorldContext object at 0x7886aedb7250&gt;}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/pac_bdd/api.py:33: in api_call
    response = httpx.get(world1pac.pac1.api_base_url)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_api.py:195: in get
    return request(
.venv/lib/python3.13/site-packages/httpx/_api.py:109: in request
    return client.request(
.venv/lib/python3.13/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
.venv/lib/python3.13/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
.venv/lib/python3.13/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @contextlib.contextmanager
    def map_httpcore_exceptions() -&gt; typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
&gt;           raise mapped_exc(message) from exc
E           httpx.ReadTimeout: timed out

.venv/lib/python3.13/site-packages/httpx/_transports/default.py:118: ReadTimeout</failure></testcase><testcase classname="test_scenario" name="test_trackingid_doublon" time="8.374"><failure message="httpx.ReadTimeout: timed out">@contextlib.contextmanager
    def map_httpcore_exceptions() -&gt; typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
&gt;           yield

.venv/lib/python3.13/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
.venv/lib/python3.13/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
.venv/lib/python3.13/site-packages/httpcore/_sync/connection.py:103: in handle_request
    return self._connection.handle_request(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:136: in handle_request
    raise exc
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:106: in handle_request
    ) = self._receive_response_headers(**kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:177: in _receive_response_headers
    event = self._receive_event(timeout=timeout)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:217: in _receive_event
    data = self._network_stream.read(
.venv/lib/python3.13/site-packages/httpcore/_backends/sync.py:126: in read
    with map_exceptions(exc_map):
         ^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

map = {&lt;class 'TimeoutError'&gt;: &lt;class 'httpcore.ReadTimeout'&gt;, &lt;class 'OSError'&gt;: &lt;class 'httpcore.ReadError'&gt;}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -&gt; typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
&gt;                   raise to_exc(exc) from exc
E                   httpcore.ReadTimeout: timed out

.venv/lib/python3.13/site-packages/httpcore/_exceptions.py:14: ReadTimeout

The above exception was the direct cause of the following exception:

fixturefunc = &lt;function api_call at 0x7886aee607c0&gt;, request = &lt;FixtureRequest for &lt;Function test_trackingid_doublon&gt;&gt;
kwargs = {'path': '/flows', 'verb': 'POST', 'world1pac': &lt;pac0.shared.test.fixture.WorldContext object at 0x7886aed6f110&gt;}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/pac_bdd/api.py:33: in api_call
    response = httpx.get(world1pac.pac1.api_base_url)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_api.py:195: in get
    return request(
.venv/lib/python3.13/site-packages/httpx/_api.py:109: in request
    return client.request(
.venv/lib/python3.13/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
.venv/lib/python3.13/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
.venv/lib/python3.13/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @contextlib.contextmanager
    def map_httpcore_exceptions() -&gt; typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
&gt;           raise mapped_exc(message) from exc
E           httpx.ReadTimeout: timed out

.venv/lib/python3.13/site-packages/httpx/_transports/default.py:118: ReadTimeout</failure></testcase><testcase classname="test_scenario" name="test_contrôle_sha256" time="8.370"><failure message="httpx.ReadTimeout: timed out">@contextlib.contextmanager
    def map_httpcore_exceptions() -&gt; typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
&gt;           yield

.venv/lib/python3.13/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
.venv/lib/python3.13/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
.venv/lib/python3.13/site-packages/httpcore/_sync/connection.py:103: in handle_request
    return self._connection.handle_request(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:136: in handle_request
    raise exc
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:106: in handle_request
    ) = self._receive_response_headers(**kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:177: in _receive_response_headers
    event = self._receive_event(timeout=timeout)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:217: in _receive_event
    data = self._network_stream.read(
.venv/lib/python3.13/site-packages/httpcore/_backends/sync.py:126: in read
    with map_exceptions(exc_map):
         ^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

map = {&lt;class 'TimeoutError'&gt;: &lt;class 'httpcore.ReadTimeout'&gt;, &lt;class 'OSError'&gt;: &lt;class 'httpcore.ReadError'&gt;}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -&gt; typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
&gt;                   raise to_exc(exc) from exc
E                   httpcore.ReadTimeout: timed out

.venv/lib/python3.13/site-packages/httpcore/_exceptions.py:14: ReadTimeout

The above exception was the direct cause of the following exception:

fixturefunc = &lt;function api_call at 0x7886aee607c0&gt;, request = &lt;FixtureRequest for &lt;Function test_contrôle_sha256&gt;&gt;
kwargs = {'path': '/flows', 'verb': 'POST', 'world1pac': &lt;pac0.shared.test.fixture.WorldContext object at 0x7886ae3d9f30&gt;}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/pac_bdd/api.py:33: in api_call
    response = httpx.get(world1pac.pac1.api_base_url)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_api.py:195: in get
    return request(
.venv/lib/python3.13/site-packages/httpx/_api.py:109: in request
    return client.request(
.venv/lib/python3.13/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
.venv/lib/python3.13/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
.venv/lib/python3.13/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @contextlib.contextmanager
    def map_httpcore_exceptions() -&gt; typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
&gt;           raise mapped_exc(message) from exc
E           httpx.ReadTimeout: timed out

.venv/lib/python3.13/site-packages/httpx/_transports/default.py:118: ReadTimeout</failure></testcase><testcase classname="test_scenario" name="test_healthcheck_api_ok" time="8.359"><failure message="httpx.ReadTimeout: timed out">@contextlib.contextmanager
    def map_httpcore_exceptions() -&gt; typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
&gt;           yield

.venv/lib/python3.13/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
.venv/lib/python3.13/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
.venv/lib/python3.13/site-packages/httpcore/_sync/connection.py:103: in handle_request
    return self._connection.handle_request(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:136: in handle_request
    raise exc
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:106: in handle_request
    ) = self._receive_response_headers(**kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:177: in _receive_response_headers
    event = self._receive_event(timeout=timeout)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpcore/_sync/http11.py:217: in _receive_event
    data = self._network_stream.read(
.venv/lib/python3.13/site-packages/httpcore/_backends/sync.py:126: in read
    with map_exceptions(exc_map):
         ^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

map = {&lt;class 'TimeoutError'&gt;: &lt;class 'httpcore.ReadTimeout'&gt;, &lt;class 'OSError'&gt;: &lt;class 'httpcore.ReadError'&gt;}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -&gt; typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
&gt;                   raise to_exc(exc) from exc
E                   httpcore.ReadTimeout: timed out

.venv/lib/python3.13/site-packages/httpcore/_exceptions.py:14: ReadTimeout

The above exception was the direct cause of the following exception:

fixturefunc = &lt;function api_call at 0x7886aee607c0&gt;, request = &lt;FixtureRequest for &lt;Function test_healthcheck_api_ok&gt;&gt;
kwargs = {'path': '/healthcheck', 'verb': 'GET', 'world1pac': &lt;pac0.shared.test.fixture.WorldContext object at 0x7886aedd3360&gt;}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/pac_bdd/api.py:33: in api_call
    response = httpx.get(world1pac.pac1.api_base_url)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_api.py:195: in get
    return request(
.venv/lib/python3.13/site-packages/httpx/_api.py:109: in request
    return client.request(
.venv/lib/python3.13/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
.venv/lib/python3.13/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
.venv/lib/python3.13/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
         ^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @contextlib.contextmanager
    def map_httpcore_exceptions() -&gt; typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
&gt;           raise mapped_exc(message) from exc
E           httpx.ReadTimeout: timed out

.venv/lib/python3.13/site-packages/httpx/_transports/default.py:118: ReadTimeout</failure></testcase><testcase classname="test_scenario" name="test_controle_format_facturx" time="0.002"><failure message="NotImplementedError">fixturefunc = &lt;function control_invoice at 0x7886aee63600&gt;, request = &lt;FixtureRequest for &lt;Function test_controle_format_facturx&gt;&gt;, kwargs = {}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @when(
        parsers.parse("je dépose pour contrôle la facture @{invoice}"),
    )
    def control_invoice():
&gt;       raise NotImplementedError()
E       NotImplementedError

src/pac_bdd/tobeimplemented.py:26: NotImplementedError</failure></testcase><testcase classname="test_scenario" name="test_démarrage_dun_serveur_nats" time="0.006"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un serveur NATS disponible&quot;. Line 18 in scenario &quot;Démarrage d'un serveur NATS&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un serveur NATS disponible". Line 18 in scenario "Démarrage d'un serveur NATS" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_connexion_dun_broker_au_serveur_nats" time="0.001"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un serveur NATS disponible&quot;. Line 22 in scenario &quot;Connexion d'un broker au serveur NATS&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un serveur NATS disponible". Line 22 in scenario "Connexion d'un broker au serveur NATS" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_démarrage_de_plusieurs_pa" time="0.001"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;2 PA démarrées&quot;. Line 31 in scenario &quot;Démarrage de plusieurs PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "2 PA démarrées". Line 31 in scenario "Démarrage de plusieurs PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_healthcheck_message" time="0.018"><failure message="AssertionError: Expected 'mock' to be called once. Called 0 times.">fixturefunc = &lt;function esb_sub_msg at 0x7886aee62ca0&gt;, request = &lt;FixtureRequest for &lt;Function test_healthcheck_message&gt;&gt;, kwargs = {'world': WorldContext()}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/pac_bdd/esb.py:14: in wrapper
    return asyncio.run(fn(*args, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:195: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
src/pac_bdd/esb.py:72: in esb_sub_msg
    handle_all.mock.assert_called_once_with("toto")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;MagicMock id='132519856946352'&gt;, args = ('toto',), kwargs = {}, msg = "Expected 'mock' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to be called once. Called 0 times.

../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:988: AssertionError</failure></testcase><testcase classname="test_scenario" name="test_canal_pingpong" time="0.009"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Then &quot;j'obtiens le message 'hello' sur le canal 'pong'&quot;. Line 10 in scenario &quot;Canal ping/pong&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/esb.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Then "j'obtiens le message 'hello' sur le canal 'pong'". Line 10 in scenario "Canal ping/pong" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/esb.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_pa" time="0.004"><failure message="NotImplementedError">fixturefunc = &lt;function job_status at 0x7886aee63f60&gt;, request = &lt;FixtureRequest for &lt;Function test_pa&gt;&gt;, kwargs = {'status': 'accepted'}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

status = 'accepted'

    @then(
        parsers.parse("j'obtiens le statut #{status}"),
    )
    def job_status(status):
        # assert False, f"statut {status} expected but not implemented !"
&gt;       raise NotImplementedError()
E       NotImplementedError

src/pac_bdd/tobeimplemented.py:56: NotImplementedError</failure></testcase><testcase classname="test_scenario" name="test_résolution_sml_réussie_pour_un_participant_enregistré" time="0.003" /><testcase classname="test_scenario" name="test_résolution_sml_échouée__participant_non_enregistré" time="0.002" /><testcase classname="test_scenario" name="test_récupération_métadonnées_smp_réussie" time="0.003" /><testcase classname="test_scenario" name="test_smp_ne_supporte_pas_le_document_type_demandé" time="0.003" /><testcase classname="test_scenario" name="test_lookup_peppol_complet_réussi_par_siren" time="0.003" /><testcase classname="test_scenario" name="test_lookup_peppol_complet_réussi_par_siret" time="0.003" /><testcase classname="test_scenario" name="test_lookup_peppol_échoué__participant_introuvable" time="0.002" /><testcase classname="test_scenario" name="test_routage_facture_vers_pa_distante_via_peppol" time="0.005" /><testcase classname="test_scenario" name="test_routage_facture__destinataire_local_pas_de_lookup_peppol" time="0.004" /><testcase classname="test_scenario" name="test_routage_facture__fallback_vers_ppf" time="0.004" /><testcase classname="test_scenario" name="test_validation_du_certificat_peppol" time="0.003" /><testcase classname="test_scenario" name="test_vérification_de_la_signature_smp" time="0.002" /><testcase classname="test_scenario" name="test_vérification_des_document_types_supportés" time="0.002"><failure message="TypeError: list indices must be integers or slices, not str">fixturefunc = &lt;function check_document_types_table at 0x7886aeeb9620&gt;, request = &lt;FixtureRequest for &lt;Function test_vérification_des_document_types_supportés&gt;&gt;
kwargs = {'datatable': [['document_type'], ['urn:oasis:names:specification:ubl:schema:xsd:Invoice-2::Invoice']], 'peppol_contex...ss Point PEPPOL', technical_contact_url=None), 'registered': True, 'scheme': '0009', 'siren': '123456789', ...}}, ...}}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = {'dns_error': None, 'dns_responses': {'B-8874539cbfa5af29d56194be355ac1b1.iso6523-actorid-upis.acc.edelivery.tech.ec.e...ess Point PEPPOL', technical_contact_url=None), 'registered': True, 'scheme': '0009', 'siren': '123456789', ...}}, ...}
datatable = [['document_type'], ['urn:oasis:names:specification:ubl:schema:xsd:Invoice-2::Invoice']]

    @then("les document types supportés incluent:")
    def check_document_types_table(peppol_context, datatable):
        """Vérifie les document types supportés."""
&gt;       expected_types = [row["document_type"] for row in datatable]
                          ^^^^^^^^^^^^^^^^^^^^
E       TypeError: list indices must be integers or slices, not str

src/pac_bdd/peppol.py:827: TypeError</failure></testcase><testcase classname="test_scenario" name="test_timeout_lors_du_lookup_sml" time="0.004" /><testcase classname="test_scenario" name="test_smp_temporairement_indisponible" time="0.003" /><testcase classname="test_scenario" name="test_retry_automatique_après_échec_temporaire" time="0.003" /><testcase classname="test_scenario" name="test_échec_définitif_après_plusieurs_retries" time="0.003" /><testcase classname="test_scenario" name="test_communication_bidirectionnelle_entre_2_pa" time="0.004"><failure message="AssertionError">fixturefunc = &lt;function check_invoice_routed_via_peppol at 0x7886aeebb6a0&gt;, request = &lt;FixtureRequest for &lt;Function test_communication_bidirectionnelle_entre_2_pa&gt;&gt;
kwargs = {'invoice_id': 'f1', 'pa_id': 'pa2', 'peppol_context': {'dns_error': None, 'dns_responses': {}, 'enterprises': {'e1': ... '0009', 'siren': '222222222', ...}}, 'environment': &lt;PeppolEnvironment.TEST: 'acc.edelivery.tech.ec.europa.eu'&gt;, ...}}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = {'dns_error': None, 'dns_responses': {}, 'enterprises': {'e1': {'endpoint': None, 'registered': False, 'scheme': '0009...: '0009', 'siren': '222222222', ...}}, 'environment': &lt;PeppolEnvironment.TEST: 'acc.edelivery.tech.ec.europa.eu'&gt;, ...}
invoice_id = 'f1', pa_id = 'pa2'

    @then(parsers.parse("la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL"))
    def check_invoice_routed_via_peppol(peppol_context, invoice_id: str, pa_id: str):
        """Vérifie que la facture est routée via PEPPOL."""
        result = peppol_context.get("routing_result")
        assert result is not None
&gt;       assert result.status == RoutingStatus.ROUTED
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError

src/pac_bdd/peppol.py:962: AssertionError</failure></testcase><testcase classname="test_scenario" name="test_réception_dune_facture_via_as4_depuis_une_pa_distante" time="0.003"><failure message="ValueError: &quot;InvoiceMessage&quot; object has no field &quot;received_via_as4&quot;">fixturefunc = &lt;function invoice_received_via_as4 at 0x7886aeebb880&gt;, request = &lt;FixtureRequest for &lt;Function test_réception_dune_facture_via_as4_depuis_une_pa_distante&gt;&gt;
kwargs = {'invoice_id': 'f1', 'peppol_context': {'dns_error': None, 'dns_responses': {}, 'enterprises': {'e1': {'endpoint': Non... '0009', 'siren': '111111111', ...}}, 'environment': &lt;PeppolEnvironment.TEST: 'acc.edelivery.tech.ec.europa.eu'&gt;, ...}}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/pac_bdd/peppol.py:979: in invoice_received_via_as4
    peppol_context["invoices"][invoice_id].received_via_as4 = True
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pydantic/main.py:1032: in __setattr__
    elif (setattr_handler := self._setattr_handler(name, value)) is not None:
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InvoiceMessage(invoice_id='f1', sender_siren='999999999', sender_siret=None, recipient_siren='123456789', recipient_siret=None, document_type='invoice_ubl', payload='&lt;Invoice&gt;...&lt;/Invoice&gt;', local_recipient=False)
name = 'received_via_as4', value = True

    def _setattr_handler(self, name: str, value: Any) -&gt; Callable[[BaseModel, str, Any], None] | None:
        """Get a handler for setting an attribute on the model instance.
    
        Returns:
            A handler for setting an attribute on the model instance. Used for memoization of the handler.
            Memoizing the handlers leads to a dramatic performance improvement in `__setattr__`
            Returns `None` when memoization is not safe, then the attribute is set directly.
        """
        cls = self.__class__
        if name in cls.__class_vars__:
            raise AttributeError(
                f'{name!r} is a ClassVar of `{cls.__name__}` and cannot be set on an instance. '
                f'If you want to set a value on the class, use `{cls.__name__}.{name} = value`.'
            )
        elif not _fields.is_valid_field_name(name):
            if (attribute := cls.__private_attributes__.get(name)) is not None:
                if hasattr(attribute, '__set__'):
                    return lambda model, _name, val: attribute.__set__(model, val)
                else:
                    return _SIMPLE_SETATTR_HANDLERS['private']
            else:
                _object_setattr(self, name, value)
                return None  # Can not return memoized handler with possibly freeform attr names
    
        attr = getattr(cls, name, None)
        # NOTE: We currently special case properties and `cached_property`, but we might need
        # to generalize this to all data/non-data descriptors at some point. For non-data descriptors
        # (such as `cached_property`), it isn't obvious though. `cached_property` caches the value
        # to the instance's `__dict__`, but other non-data descriptors might do things differently.
        if isinstance(attr, cached_property):
            return _SIMPLE_SETATTR_HANDLERS['cached_property']
    
        _check_frozen(cls, name, value)
    
        # We allow properties to be set only on non frozen models for now (to match dataclasses).
        # This can be changed if it ever gets requested.
        if isinstance(attr, property):
            return lambda model, _name, val: attr.__set__(model, val)
        elif cls.model_config.get('validate_assignment'):
            return _SIMPLE_SETATTR_HANDLERS['validate_assignment']
        elif name not in cls.__pydantic_fields__:
            if cls.model_config.get('extra') != 'allow':
                # TODO - matching error
&gt;               raise ValueError(f'"{cls.__name__}" object has no field "{name}"')
E               ValueError: "InvoiceMessage" object has no field "received_via_as4"

.venv/lib/python3.13/site-packages/pydantic/main.py:1079: ValueError</failure></testcase><testcase classname="test_scenario" name="test_facture_b2g_via_chorus_pro_peppol" time="0.004" /><testcase classname="test_scenario" name="test_rejet_dolibarr" time="0.001"><failure message="NotImplementedError">fixturefunc = &lt;function compliance_rule_set at 0x7886aee63ba0&gt;, request = &lt;FixtureRequest for &lt;Function test_rejet_dolibarr&gt;&gt;, kwargs = {}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @when("je définis un contrôle de conformité métier fournisseur")
    def compliance_rule_set():
&gt;       raise NotImplementedError()
E       NotImplementedError

src/pac_bdd/tobeimplemented.py:41: NotImplementedError</failure></testcase><testcase classname="test_scenario" name="test_facture_rejetée" time="0.001"><failure message="NotImplementedError">fixturefunc = &lt;function submit_invoice_simple at 0x7886aee63240&gt;, request = &lt;FixtureRequest for &lt;Function test_facture_rejetée&gt;&gt;, kwargs = {}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @when("je dépose une facture")
    def submit_invoice_simple():
        # POST /
&gt;       raise NotImplementedError()
E       NotImplementedError

src/pac_bdd/tobeimplemented.py:13: NotImplementedError</failure></testcase></testsuite></testsuites>