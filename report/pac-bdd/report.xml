<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="56" skipped="0" tests="64" time="245.977" timestamp="2026-01-13T17:53:07.309261+01:00" hostname="gpd"><testcase classname="test_fixture" name="test_dummy_fixture" time="0.000" /><testcase classname="test_fixture" name="test_dummy_async_fixture" time="0.001" /><testcase classname="test_openapi" name="test_swagger_flow_service" time="0.000"><failure message="NotImplementedError: swagger compliance non testé">def test_swagger_flow_service():
        url = '???'
&gt;       _test_swagger(
            url,
            "docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE A - PR XP Z12-013 - AFNOR-Flow_Service-1.1.0-swagger.json",
        )

test_openapi.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

url = '???', swagger = 'docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE A - PR XP Z12-013 - AFNOR-Flow_Service-1.1.0-swagger.json'

    def _test_swagger(url: str, swagger: str):
        """
            Vérifier si une API respecte une definition Swagger/OpenAPI
    
        Cette API doit respecter le versioning indiqué dans l’URL de la route API du Swagger. Dans un objectif de
        simplification le versioning des routes n’est pas affiché dans le présent document;
        Dans cette API publiée par le Fournisseur API ce dernier peut :
        •Avoir une URL spécifique en amont du versioning
        •Ajouter des propriétés aux objets dans les requêtes.
        •Ajouter des paramètres aux routes dans les requêtes.
        •Ajouter des propriétés aux objets dans les réponses.
        •Ajouter des codes erreurs dans les réponses.
        """
&gt;       raise NotImplementedError("swagger compliance non testé")
E       NotImplementedError: swagger compliance non testé

test_openapi.py:18: NotImplementedError</failure></testcase><testcase classname="test_openapi" name="test_swagger_directory_service" time="0.000"><failure message="NotImplementedError: swagger compliance non testé">def test_swagger_directory_service():
        url = "???"
&gt;       _test_swagger(
            url,
            "docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE B - PR XP Z12-013 - AFNOR-Directory_Service-1.1.0-swagger.json",
        )

test_openapi.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

url = '???', swagger = 'docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE B - PR XP Z12-013 - AFNOR-Directory_Service-1.1.0-swagger.json'

    def _test_swagger(url: str, swagger: str):
        """
            Vérifier si une API respecte une definition Swagger/OpenAPI
    
        Cette API doit respecter le versioning indiqué dans l’URL de la route API du Swagger. Dans un objectif de
        simplification le versioning des routes n’est pas affiché dans le présent document;
        Dans cette API publiée par le Fournisseur API ce dernier peut :
        •Avoir une URL spécifique en amont du versioning
        •Ajouter des propriétés aux objets dans les requêtes.
        •Ajouter des paramètres aux routes dans les requêtes.
        •Ajouter des propriétés aux objets dans les réponses.
        •Ajouter des codes erreurs dans les réponses.
        """
&gt;       raise NotImplementedError("swagger compliance non testé")
E       NotImplementedError: swagger compliance non testé

test_openapi.py:18: NotImplementedError</failure></testcase><testcase classname="test_pac0" name="test_pac0_import_services" time="0.016"><failure message="AttributeError(&quot;'FastAPI' object has no attribute 'run'&quot;) [single exception in ExceptionGroup]">+ Exception Group Traceback (most recent call last):
  |   File "/home/philippe/src/PA_Communautaire/packages/pac-bdd/test_pac0.py", line 21, in test_pac0_import_services
  |     async with asyncio.TaskGroup() as tg:
  |                ~~~~~~~~~~~~~~~~~^^
  |   File "/home/philippe/.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/taskgroups.py", line 71, in __aexit__
  |     return await self._aexit(et, exc)
  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/home/philippe/.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/taskgroups.py", line 173, in _aexit
  |     raise BaseExceptionGroup(
  |     ...&lt;2 lines&gt;...
  |     ) from None
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "/home/philippe/src/PA_Communautaire/packages/pac-bdd/test_pac0.py", line 22, in test_pac0_import_services
    |     task1 = tg.create_task(api_gateway_main.app.run())
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
    | AttributeError: 'FastAPI' object has no attribute 'run'
    +------------------------------------</failure></testcase><testcase classname="test_scenario" name="test_trackingid_fourni" time="40.304"><failure message="TimeoutError: Service api_gateway failed to start within 30.0s">self = &lt;FixtureRequest for &lt;Function test_trackingid_fourni&gt;&gt;, argname = 'world1'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:743: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:313: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:309: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
../pac0/src/pac0/shared/test/world.py:338: in world1
    await world.pa_new()
../pac0/src/pac0/shared/test/world.py:71: in pa_new
    await asyncio.gather(*tasks)
../pac0/src/pac0/shared/test/service/pac.py:58: in __aenter__
    await asyncio.gather(*[s.__aenter__() for s in self._services()])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pac0.shared.test.service.fastapi.FastApiServiceContext object at 0x7d037abd78c0&gt;

    async def __aenter__(self) -&gt; Self:
        """Start the service subprocess."""
        if self.config.port == 0:
            self.config.port = find_available_port(start_port=8000)
        logger.info(
            f"Starting service {self.config.name} on port {self.config.port} : {' '.join(self.config.command)}"
        )
        env = os.environ.copy()
        env["PORT"] = str(self.config.port)
        if self.config.env_var_extra:
            env.update(self.config.env_var_extra)
        command = [c.format(**env) for c in self.config.command]
    
        self._process = subprocess.Popen(
            command,
            # stdout=subprocess.PIPE,  # self.config.stdout,
            # stderr=subprocess.PIPE,  # self.config.stderr,
            text=True,
            env=env,
            cwd=PACKAGE_BASE_FOLDER,
        )
    
        # Wait for service to be ready
        self.is_ready = await self.wait_for_ready(self.config.startup_timeout)
        if not self.is_ready:
            await self._terminate()
&gt;           raise TimeoutError(
                f"Service {self.config.name} failed to start within {self.config.startup_timeout}s"
            )
E           TimeoutError: Service api_gateway failed to start within 30.0s

../pac0/src/pac0/shared/test/service/base.py:157: TimeoutError</failure></testcase><testcase classname="test_scenario" name="test_trackingid_absent" time="40.272"><failure message="TimeoutError: Service api_gateway failed to start within 30.0s">self = &lt;FixtureRequest for &lt;Function test_trackingid_absent&gt;&gt;, argname = 'world1'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:743: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:313: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:309: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
../pac0/src/pac0/shared/test/world.py:338: in world1
    await world.pa_new()
../pac0/src/pac0/shared/test/world.py:71: in pa_new
    await asyncio.gather(*tasks)
../pac0/src/pac0/shared/test/service/pac.py:58: in __aenter__
    await asyncio.gather(*[s.__aenter__() for s in self._services()])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pac0.shared.test.service.fastapi.FastApiServiceContext object at 0x7d037ab27d90&gt;

    async def __aenter__(self) -&gt; Self:
        """Start the service subprocess."""
        if self.config.port == 0:
            self.config.port = find_available_port(start_port=8000)
        logger.info(
            f"Starting service {self.config.name} on port {self.config.port} : {' '.join(self.config.command)}"
        )
        env = os.environ.copy()
        env["PORT"] = str(self.config.port)
        if self.config.env_var_extra:
            env.update(self.config.env_var_extra)
        command = [c.format(**env) for c in self.config.command]
    
        self._process = subprocess.Popen(
            command,
            # stdout=subprocess.PIPE,  # self.config.stdout,
            # stderr=subprocess.PIPE,  # self.config.stderr,
            text=True,
            env=env,
            cwd=PACKAGE_BASE_FOLDER,
        )
    
        # Wait for service to be ready
        self.is_ready = await self.wait_for_ready(self.config.startup_timeout)
        if not self.is_ready:
            await self._terminate()
&gt;           raise TimeoutError(
                f"Service {self.config.name} failed to start within {self.config.startup_timeout}s"
            )
E           TimeoutError: Service api_gateway failed to start within 30.0s

../pac0/src/pac0/shared/test/service/base.py:157: TimeoutError</failure></testcase><testcase classname="test_scenario" name="test_trackingid_doublon" time="40.330"><failure message="TimeoutError: Service api_gateway failed to start within 30.0s">self = &lt;FixtureRequest for &lt;Function test_trackingid_doublon&gt;&gt;, argname = 'world1'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:743: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:313: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:309: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
../pac0/src/pac0/shared/test/world.py:338: in world1
    await world.pa_new()
../pac0/src/pac0/shared/test/world.py:71: in pa_new
    await asyncio.gather(*tasks)
../pac0/src/pac0/shared/test/service/pac.py:58: in __aenter__
    await asyncio.gather(*[s.__aenter__() for s in self._services()])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pac0.shared.test.service.fastapi.FastApiServiceContext object at 0x7d037ab26c10&gt;

    async def __aenter__(self) -&gt; Self:
        """Start the service subprocess."""
        if self.config.port == 0:
            self.config.port = find_available_port(start_port=8000)
        logger.info(
            f"Starting service {self.config.name} on port {self.config.port} : {' '.join(self.config.command)}"
        )
        env = os.environ.copy()
        env["PORT"] = str(self.config.port)
        if self.config.env_var_extra:
            env.update(self.config.env_var_extra)
        command = [c.format(**env) for c in self.config.command]
    
        self._process = subprocess.Popen(
            command,
            # stdout=subprocess.PIPE,  # self.config.stdout,
            # stderr=subprocess.PIPE,  # self.config.stderr,
            text=True,
            env=env,
            cwd=PACKAGE_BASE_FOLDER,
        )
    
        # Wait for service to be ready
        self.is_ready = await self.wait_for_ready(self.config.startup_timeout)
        if not self.is_ready:
            await self._terminate()
&gt;           raise TimeoutError(
                f"Service {self.config.name} failed to start within {self.config.startup_timeout}s"
            )
E           TimeoutError: Service api_gateway failed to start within 30.0s

../pac0/src/pac0/shared/test/service/base.py:157: TimeoutError</failure></testcase><testcase classname="test_scenario" name="test_démarragearrêt_service_api_gateway" time="1.260" /><testcase classname="test_scenario" name="test_contrôle_sha256" time="40.343"><failure message="TimeoutError: Service api_gateway failed to start within 30.0s">self = &lt;FixtureRequest for &lt;Function test_contrôle_sha256&gt;&gt;, argname = 'world1'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:743: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:313: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:309: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
../pac0/src/pac0/shared/test/world.py:338: in world1
    await world.pa_new()
../pac0/src/pac0/shared/test/world.py:71: in pa_new
    await asyncio.gather(*tasks)
../pac0/src/pac0/shared/test/service/pac.py:58: in __aenter__
    await asyncio.gather(*[s.__aenter__() for s in self._services()])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pac0.shared.test.service.fastapi.FastApiServiceContext object at 0x7d0379d80640&gt;

    async def __aenter__(self) -&gt; Self:
        """Start the service subprocess."""
        if self.config.port == 0:
            self.config.port = find_available_port(start_port=8000)
        logger.info(
            f"Starting service {self.config.name} on port {self.config.port} : {' '.join(self.config.command)}"
        )
        env = os.environ.copy()
        env["PORT"] = str(self.config.port)
        if self.config.env_var_extra:
            env.update(self.config.env_var_extra)
        command = [c.format(**env) for c in self.config.command]
    
        self._process = subprocess.Popen(
            command,
            # stdout=subprocess.PIPE,  # self.config.stdout,
            # stderr=subprocess.PIPE,  # self.config.stderr,
            text=True,
            env=env,
            cwd=PACKAGE_BASE_FOLDER,
        )
    
        # Wait for service to be ready
        self.is_ready = await self.wait_for_ready(self.config.startup_timeout)
        if not self.is_ready:
            await self._terminate()
&gt;           raise TimeoutError(
                f"Service {self.config.name} failed to start within {self.config.startup_timeout}s"
            )
E           TimeoutError: Service api_gateway failed to start within 30.0s

../pac0/src/pac0/shared/test/service/base.py:157: TimeoutError</failure></testcase><testcase classname="test_scenario" name="test_healthcheck_ok" time="40.300"><failure message="TimeoutError: Service api_gateway failed to start within 30.0s">self = &lt;FixtureRequest for &lt;Function test_healthcheck_ok&gt;&gt;, argname = 'world1'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:743: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:313: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:309: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
../pac0/src/pac0/shared/test/world.py:338: in world1
    await world.pa_new()
../pac0/src/pac0/shared/test/world.py:71: in pa_new
    await asyncio.gather(*tasks)
../pac0/src/pac0/shared/test/service/pac.py:58: in __aenter__
    await asyncio.gather(*[s.__aenter__() for s in self._services()])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pac0.shared.test.service.fastapi.FastApiServiceContext object at 0x7d037ade67b0&gt;

    async def __aenter__(self) -&gt; Self:
        """Start the service subprocess."""
        if self.config.port == 0:
            self.config.port = find_available_port(start_port=8000)
        logger.info(
            f"Starting service {self.config.name} on port {self.config.port} : {' '.join(self.config.command)}"
        )
        env = os.environ.copy()
        env["PORT"] = str(self.config.port)
        if self.config.env_var_extra:
            env.update(self.config.env_var_extra)
        command = [c.format(**env) for c in self.config.command]
    
        self._process = subprocess.Popen(
            command,
            # stdout=subprocess.PIPE,  # self.config.stdout,
            # stderr=subprocess.PIPE,  # self.config.stderr,
            text=True,
            env=env,
            cwd=PACKAGE_BASE_FOLDER,
        )
    
        # Wait for service to be ready
        self.is_ready = await self.wait_for_ready(self.config.startup_timeout)
        if not self.is_ready:
            await self._terminate()
&gt;           raise TimeoutError(
                f"Service {self.config.name} failed to start within {self.config.startup_timeout}s"
            )
E           TimeoutError: Service api_gateway failed to start within 30.0s

../pac0/src/pac0/shared/test/service/base.py:157: TimeoutError</failure></testcase><testcase classname="test_scenario" name="test_healthcheck_full_ok" time="40.218"><failure message="TimeoutError: Service api_gateway failed to start within 30.0s">self = &lt;FixtureRequest for &lt;Function test_healthcheck_full_ok&gt;&gt;, argname = 'world1'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:743: in pytest_fixture_setup
    hook_result = yield
                  ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:313: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:309: in setup
    res = await gen_obj.__anext__()
          ^^^^^^^^^^^^^^^^^^^^^^^^^
../pac0/src/pac0/shared/test/world.py:338: in world1
    await world.pa_new()
../pac0/src/pac0/shared/test/world.py:71: in pa_new
    await asyncio.gather(*tasks)
../pac0/src/pac0/shared/test/service/pac.py:58: in __aenter__
    await asyncio.gather(*[s.__aenter__() for s in self._services()])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pac0.shared.test.service.fastapi.FastApiServiceContext object at 0x7d037aaddae0&gt;

    async def __aenter__(self) -&gt; Self:
        """Start the service subprocess."""
        if self.config.port == 0:
            self.config.port = find_available_port(start_port=8000)
        logger.info(
            f"Starting service {self.config.name} on port {self.config.port} : {' '.join(self.config.command)}"
        )
        env = os.environ.copy()
        env["PORT"] = str(self.config.port)
        if self.config.env_var_extra:
            env.update(self.config.env_var_extra)
        command = [c.format(**env) for c in self.config.command]
    
        self._process = subprocess.Popen(
            command,
            # stdout=subprocess.PIPE,  # self.config.stdout,
            # stderr=subprocess.PIPE,  # self.config.stderr,
            text=True,
            env=env,
            cwd=PACKAGE_BASE_FOLDER,
        )
    
        # Wait for service to be ready
        self.is_ready = await self.wait_for_ready(self.config.startup_timeout)
        if not self.is_ready:
            await self._terminate()
&gt;           raise TimeoutError(
                f"Service {self.config.name} failed to start within {self.config.startup_timeout}s"
            )
E           TimeoutError: Service api_gateway failed to start within 30.0s

../pac0/src/pac0/shared/test/service/base.py:157: TimeoutError</failure></testcase><testcase classname="test_scenario" name="test_controle_format_facturx" time="0.001"><failure message="NotImplementedError">fixturefunc = &lt;function control_invoice at 0x7d037ae719e0&gt;, request = &lt;FixtureRequest for &lt;Function test_controle_format_facturx&gt;&gt;, kwargs = {}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @when(
        parsers.parse("je dépose pour contrôle la facture @{invoice}"),
    )
    def control_invoice():
&gt;       raise NotImplementedError()
E       NotImplementedError

src/pac_bdd/tobeimplemented.py:30: NotImplementedError</failure></testcase><testcase classname="test_scenario" name="test_démarrage_dun_serveur_nats" time="0.001"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un serveur NATS disponible&quot;. Line 19 in scenario &quot;Démarrage d'un serveur NATS&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un serveur NATS disponible". Line 19 in scenario "Démarrage d'un serveur NATS" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_connexion_dun_broker_au_serveur_nats" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un serveur NATS disponible&quot;. Line 23 in scenario &quot;Connexion d'un broker au serveur NATS&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un serveur NATS disponible". Line 23 in scenario "Connexion d'un broker au serveur NATS" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_démarrage_de_plusieurs_pa" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;2 PA démarrées&quot;. Line 32 in scenario &quot;Démarrage de plusieurs PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "2 PA démarrées". Line 32 in scenario "Démarrage de plusieurs PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_démarrage_dun_service_nats_local" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service NATS local&quot;. Line 21 in scenario &quot;Démarrage d'un service NATS local&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service NATS local". Line 21 in scenario "Démarrage d'un service NATS local" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_connexion_à_un_service_nats_distant" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service NATS local comme référence&quot;. Line 27 in scenario &quot;Connexion à un service NATS distant&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service NATS local comme référence". Line 27 in scenario "Connexion à un service NATS distant" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_démarrage_dun_service_peppol_mock" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service Peppol en mode mock&quot;. Line 33 in scenario &quot;Démarrage d'un service Peppol mock&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service Peppol en mode mock". Line 33 in scenario "Démarrage d'un service Peppol mock" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_configuration_des_réponses_peppol_mock" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service Peppol en mode mock&quot;. Line 38 in scenario &quot;Configuration des réponses Peppol mock&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service Peppol en mode mock". Line 38 in scenario "Configuration des réponses Peppol mock" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_recherche_peppol_dune_entreprise_non_enregistrée" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service Peppol en mode mock&quot;. Line 45 in scenario &quot;Recherche Peppol d'une entreprise non enregistrée&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service Peppol en mode mock". Line 45 in scenario "Recherche Peppol d'une entreprise non enregistrée" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_démarrage_dun_service_pa" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service PA&quot;. Line 51 in scenario &quot;Démarrage d'un service PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service PA". Line 51 in scenario "Démarrage d'un service PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_création_dun_monde_avec_1_pa" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 1 PA&quot;. Line 61 in scenario &quot;Création d'un monde avec 1 PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 1 PA". Line 61 in scenario "Création d'un monde avec 1 PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_création_dun_monde_avec_2_pa" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA&quot;. Line 68 in scenario &quot;Création d'un monde avec 2 PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA". Line 68 in scenario "Création d'un monde avec 2 PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_création_dun_monde_avec_4_pa" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 4 PA&quot;. Line 74 in scenario &quot;Création d'un monde avec 4 PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 4 PA". Line 74 in scenario "Création d'un monde avec 4 PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_les_pa_partagent_le_même_service_nats" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA&quot;. Line 82 in scenario &quot;Les PA partagent le même service NATS&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA". Line 82 in scenario "Les PA partagent le même service NATS" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_les_pa_ont_des_ports_api_distincts" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 3 PA&quot;. Line 87 in scenario &quot;Les PA ont des ports API distincts&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 3 PA". Line 87 in scenario "Les PA ont des ports API distincts" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_toutes_les_pa_répondent_au_healthcheck" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA&quot;. Line 95 in scenario &quot;Toutes les PA répondent au healthcheck&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA". Line 95 in scenario "Toutes les PA répondent au healthcheck" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_information_du_monde" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA&quot;. Line 104 in scenario &quot;Information du monde&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA". Line 104 in scenario "Information du monde" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_arrêt_propre_du_monde" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA démarré&quot;. Line 115 in scenario &quot;Arrêt propre du monde&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA démarré". Line 115 in scenario "Arrêt propre du monde" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_monde_avec_nats_externe" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service NATS local comme référence&quot;. Line 126 in scenario &quot;Monde avec NATS externe&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service NATS local comme référence". Line 126 in scenario "Monde avec NATS externe" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_monde_avec_peppol_personnalisé" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service Peppol en mode mock comme référence&quot;. Line 132 in scenario &quot;Monde avec Peppol personnalisé&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service Peppol en mode mock comme référence". Line 132 in scenario "Monde avec Peppol personnalisé" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_dépôt_de_facture_entre_2_pa_via_peppol" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA&quot;. Line 141 in scenario &quot;Dépôt de facture entre 2 PA via Peppol&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA". Line 141 in scenario "Dépôt de facture entre 2 PA via Peppol" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_démarragearrêt_service_esb_central" time="0.004" /><testcase classname="test_scenario" name="test_healthcheck_message" time="0.006"><failure message="AttributeError: 'WorldContext' object has no attribute 'pac'. Did you mean: 'pa'?">fixturefunc = &lt;function esb_sub at 0x7d037ae70b80&gt;, request = &lt;FixtureRequest for &lt;Function test_healthcheck_message&gt;&gt;
kwargs = {'canal': 'healthcheck', 'world': WorldContext(peppol=&lt;pac0.shared.test.service.dns.DNSServiceContext object at 0x7d037ab757b0&gt;, pas=[])}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/pac_bdd/esb.py:18: in wrapper
    return asyncio.run(fn(*args, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:195: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

world = WorldContext(peppol=&lt;pac0.shared.test.service.dns.DNSServiceContext object at 0x7d037ab757b0&gt;, pas=[]), canal = 'healthcheck'

    @when(
        parsers.parse("j'écoute le canal '{canal}'"),
    )
    @async_to_sync
    async def esb_sub(
        world: WorldContextOld,
        canal: str,
    ):
        global handle_GLOBAL
    
        print(f"esb_sub {canal=}...")
        #raise NotImplementedError()
&gt;       broker = world.pac.broker
                 ^^^^^^^^^
E       AttributeError: 'WorldContext' object has no attribute 'pac'. Did you mean: 'pa'?

src/pac_bdd/esb.py:38: AttributeError</failure></testcase><testcase classname="test_scenario" name="test_canal_pingpong" time="0.007"><failure message="AttributeError: 'WorldContext' object has no attribute 'pac'. Did you mean: 'pa'?">fixturefunc = &lt;function esb_sub at 0x7d037ae70b80&gt;, request = &lt;FixtureRequest for &lt;Function test_canal_pingpong&gt;&gt;
kwargs = {'canal': 'pong', 'world': WorldContext(peppol=&lt;pac0.shared.test.service.dns.DNSServiceContext object at 0x7d037ab745a0&gt;, pas=[])}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/pac_bdd/esb.py:18: in wrapper
    return asyncio.run(fn(*args, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:195: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

world = WorldContext(peppol=&lt;pac0.shared.test.service.dns.DNSServiceContext object at 0x7d037ab745a0&gt;, pas=[]), canal = 'pong'

    @when(
        parsers.parse("j'écoute le canal '{canal}'"),
    )
    @async_to_sync
    async def esb_sub(
        world: WorldContextOld,
        canal: str,
    ):
        global handle_GLOBAL
    
        print(f"esb_sub {canal=}...")
        #raise NotImplementedError()
&gt;       broker = world.pac.broker
                 ^^^^^^^^^
E       AttributeError: 'WorldContext' object has no attribute 'pac'. Did you mean: 'pa'?

src/pac_bdd/esb.py:38: AttributeError</failure></testcase><testcase classname="test_scenario" name="test_pa" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">fixturefunc = &lt;function pa_defined at 0x7d037ad120c0&gt;, request = &lt;FixtureRequest for &lt;Function test_pa&gt;&gt;
kwargs = {'pa_id': 'pa1', 'peppol_context': PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None), pa_id = 'pa1'

    @given(parsers.parse("la PA #{pa_id}"))
    def pa_defined(peppol_context, pa_id: str):
        """Définit une PA."""
&gt;       peppol_context["pas"][pa_id] = {
        ^^^^^^^^^^^^^^^^^^^^^
            "id": pa_id,
            "enterprises": [],
            "endpoint": f"https://ap.{pa_id}.fr/as4",
        }
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:307: TypeError</failure></testcase><testcase classname="test_scenario" name="test_résolution_sml_réussie_pour_un_participant_enregistré" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_résolution_sml_réussie_pour_un_participant_enregistré&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_résolution_sml_échouée__participant_non_enregistré" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_résolution_sml_échouée__participant_non_enregistré&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_récupération_métadonnées_smp_réussie" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_récupération_métadonnées_smp_réussie&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_smp_ne_supporte_pas_le_document_type_demandé" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_smp_ne_supporte_pas_le_document_type_demandé&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_lookup_peppol_complet_réussi_par_siren" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_lookup_peppol_complet_réussi_par_siren&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_lookup_peppol_complet_réussi_par_siret" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_lookup_peppol_complet_réussi_par_siret&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_lookup_peppol_échoué__participant_introuvable" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_lookup_peppol_échoué__participant_introuvable&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_routage_facture_vers_pa_distante_via_peppol" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_routage_facture_vers_pa_distante_via_peppol&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_routage_facture__destinataire_local_pas_de_lookup_peppol" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_routage_facture__destinataire_local_pas_de_lookup_peppol&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_routage_facture__fallback_vers_ppf" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_routage_facture__fallback_vers_ppf&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_validation_du_certificat_peppol" time="0.007"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_validation_du_certificat_peppol&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_vérification_de_la_signature_smp" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_vérification_de_la_signature_smp&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_vérification_des_document_types_supportés" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_vérification_des_document_types_supportés&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_timeout_lors_du_lookup_sml" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_timeout_lors_du_lookup_sml&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_smp_temporairement_indisponible" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_smp_temporairement_indisponible&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_retry_automatique_après_échec_temporaire" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_retry_automatique_après_échec_temporaire&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_échec_définitif_après_plusieurs_retries" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_échec_définitif_après_plusieurs_retries&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_communication_bidirectionnelle_entre_2_pa" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_communication_bidirectionnelle_entre_2_pa&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_réception_dune_facture_via_as4_depuis_une_pa_distante" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_réception_dune_facture_via_as4_depuis_une_pa_distante&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_facture_b2g_via_chorus_pro_peppol" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_facture_b2g_via_chorus_pro_peppol&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:103: TypeError</failure></testcase><testcase classname="test_scenario" name="test_peppol_req" time="0.005" /><testcase classname="test_scenario" name="test_md5" time="0.002"><failure message="AssertionError">fixturefunc = &lt;function check_result at 0x7d037ad10400&gt;, request = &lt;FixtureRequest for &lt;Function test_md5&gt;&gt;
kwargs = {'peppol_context': PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result='b881aaeff8eeaed7190491ccdeaa42fc'), 'result': '6c2675d749449f2c8af1216fd866bb54'}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result='b881aaeff8eeaed7190491ccdeaa42fc'), result = '6c2675d749449f2c8af1216fd866bb54'

    @then(parsers.parse('''j'obtiens "{result}"'''))
    def check_result(
        peppol_context: PeppolContext,
        result: str,
    ):
        """étape générique pour tester tout résultat"""
        if peppol_context.result != result:
            print(f"result: {peppol_context.result}")
            print(f"expecting: {result}")
&gt;       assert peppol_context.result == result
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError

src/pac_bdd/peppol.py:128: AssertionError</failure></testcase><testcase classname="test_scenario" name="test_identification_france" time="0.001" /><testcase classname="test_scenario" name="test_empreinte_participant" time="0.001" /><testcase classname="test_scenario" name="test_hôte_sml" time="0.002" /><testcase classname="test_scenario" name="test_rejet_dolibarr" time="0.000"><failure message="NotImplementedError">fixturefunc = &lt;function compliance_rule_set at 0x7d037ae71f80&gt;, request = &lt;FixtureRequest for &lt;Function test_rejet_dolibarr&gt;&gt;, kwargs = {}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @when("je définis un contrôle de conformité métier fournisseur")
    def compliance_rule_set():
&gt;       raise NotImplementedError()
E       NotImplementedError

src/pac_bdd/tobeimplemented.py:45: NotImplementedError</failure></testcase><testcase classname="test_scenario" name="test_facture_rejetée" time="0.001"><failure message="NotImplementedError">fixturefunc = &lt;function submit_invoice_simple at 0x7d037ae71620&gt;, request = &lt;FixtureRequest for &lt;Function test_facture_rejetée&gt;&gt;, kwargs = {}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @when("je dépose une facture")
    def submit_invoice_simple():
        # POST /
&gt;       raise NotImplementedError()
E       NotImplementedError

src/pac_bdd/tobeimplemented.py:17: NotImplementedError</failure></testcase></testsuite></testsuites>