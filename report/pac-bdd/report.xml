<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="55" skipped="0" tests="61" time="1.764" timestamp="2026-01-12T19:55:24.562000+01:00" hostname="gpd"><testcase classname="test_fixture" name="test_dummy_fixture" time="0.000" /><testcase classname="test_fixture" name="test_dummy_async_fixture" time="0.002" /><testcase classname="test_openapi" name="test_swagger_flow_service" time="0.000"><failure message="NotImplementedError: swagger compliance non testé">def test_swagger_flow_service():
        url = '???'
&gt;       _test_swagger(
            url,
            "docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE A - PR XP Z12-013 - AFNOR-Flow_Service-1.1.0-swagger.json",
        )

test_openapi.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

url = '???', swagger = 'docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE A - PR XP Z12-013 - AFNOR-Flow_Service-1.1.0-swagger.json'

    def _test_swagger(url: str, swagger: str):
        """
            Vérifier si une API respecte une definition Swagger/OpenAPI
    
        Cette API doit respecter le versioning indiqué dans l’URL de la route API du Swagger. Dans un objectif de
        simplification le versioning des routes n’est pas affiché dans le présent document;
        Dans cette API publiée par le Fournisseur API ce dernier peut :
        •Avoir une URL spécifique en amont du versioning
        •Ajouter des propriétés aux objets dans les requêtes.
        •Ajouter des paramètres aux routes dans les requêtes.
        •Ajouter des propriétés aux objets dans les réponses.
        •Ajouter des codes erreurs dans les réponses.
        """
&gt;       raise NotImplementedError("swagger compliance non testé")
E       NotImplementedError: swagger compliance non testé

test_openapi.py:14: NotImplementedError</failure></testcase><testcase classname="test_openapi" name="test_swagger_directory_service" time="0.000"><failure message="NotImplementedError: swagger compliance non testé">def test_swagger_directory_service():
        url = "???"
&gt;       _test_swagger(
            url,
            "docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE B - PR XP Z12-013 - AFNOR-Directory_Service-1.1.0-swagger.json",
        )

test_openapi.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

url = '???', swagger = 'docs/norme/XP_Z12-013_SWAGGER_Annexes_A_et_B_V1.2/ANNEXE B - PR XP Z12-013 - AFNOR-Directory_Service-1.1.0-swagger.json'

    def _test_swagger(url: str, swagger: str):
        """
            Vérifier si une API respecte une definition Swagger/OpenAPI
    
        Cette API doit respecter le versioning indiqué dans l’URL de la route API du Swagger. Dans un objectif de
        simplification le versioning des routes n’est pas affiché dans le présent document;
        Dans cette API publiée par le Fournisseur API ce dernier peut :
        •Avoir une URL spécifique en amont du versioning
        •Ajouter des propriétés aux objets dans les requêtes.
        •Ajouter des paramètres aux routes dans les requêtes.
        •Ajouter des propriétés aux objets dans les réponses.
        •Ajouter des codes erreurs dans les réponses.
        """
&gt;       raise NotImplementedError("swagger compliance non testé")
E       NotImplementedError: swagger compliance non testé

test_openapi.py:14: NotImplementedError</failure></testcase><testcase classname="test_pac0" name="test_pac0_import_services" time="0.009"><failure message="AttributeError(&quot;'FastAPI' object has no attribute 'run'&quot;) [single exception in ExceptionGroup]">+ Exception Group Traceback (most recent call last):
  |   File "/home/philippe/src/PA_Communautaire/packages/pac-bdd/test_pac0.py", line 17, in test_pac0_import_services
  |     async with asyncio.TaskGroup() as tg:
  |                ~~~~~~~~~~~~~~~~~^^
  |   File "/home/philippe/.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/taskgroups.py", line 71, in __aexit__
  |     return await self._aexit(et, exc)
  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "/home/philippe/.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/taskgroups.py", line 173, in _aexit
  |     raise BaseExceptionGroup(
  |     ...&lt;2 lines&gt;...
  |     ) from None
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "/home/philippe/src/PA_Communautaire/packages/pac-bdd/test_pac0.py", line 18, in test_pac0_import_services
    |     task1 = tg.create_task(api_gateway_main.app.run())
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
    | AttributeError: 'FastAPI' object has no attribute 'run'
    +------------------------------------</failure></testcase><testcase classname="test_scenario" name="test_trackingid_fourni" time="0.002"><failure message="file /home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py, line 296&#10;          def scenario_wrapper(request: FixtureRequest, _pytest_bdd_example: dict[str, str]) -&gt; Any:&#10;E       fixture 'world1pac' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pytest_bdd_example, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, auth, author, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, doctest_namespace, event_loop_policy, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, monkeypatch, pac, peppol_context, peppol_service, pytestbdd_stepdef_given_#{enterprise_id} ne supporte que les factures UBL, pytestbdd_stepdef_given_#{entity_id} accessible via Chorus Pro sur PEPPOL, pytestbdd_stepdef_given_#{pa_id1} et #{pa_id2} enregistrées mutuellement sur PEPPOL, pytestbdd_stepdef_given_l'entité publique #{entity_id} avec le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIREN &quot;{siren}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL avec scheme &quot;{scheme}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id}, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id} via PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} non enregistrée sur PEPPOL, pytestbdd_stepdef_given_la PA #{pa_id}, pytestbdd_stepdef_given_la facture #{invoice_id} de #{sender_id} à #{recipient_id}, pytestbdd_stepdef_given_la racine SML &quot;{zone}&quot;, pytestbdd_stepdef_given_le SML de test &quot;{sml_zone}&quot;, pytestbdd_stepdef_given_le SMP de #{enterprise_id} accessible à &quot;{smp_url}&quot;, pytestbdd_stepdef_given_le SMP de #{enterprise_id} disponible après {delay:d} secondes, pytestbdd_stepdef_given_le SMP de #{enterprise_id} définitivement indisponible, pytestbdd_stepdef_given_le SMP de #{enterprise_id} indisponible la première fois, pytestbdd_stepdef_given_le SMP de #{enterprise_id} temporairement indisponible (HTTP 503), pytestbdd_stepdef_given_le destinataire de #{invoice_id} est #{enterprise_id}, pytestbdd_stepdef_given_le service PEPPOL configuré en mode &quot;{mode}&quot;, pytestbdd_stepdef_given_le service PEPPOL simulé avec:, pytestbdd_stepdef_given_trace, pytestbdd_stepdef_given_un SML de test lent, pytestbdd_stepdef_given_un timeout configuré à {timeout:d} secondes, pytestbdd_stepdef_given_un utilisateur, pytestbdd_stepdef_given_un utilisateur de la PA #{pa}, pytestbdd_stepdef_given_une facture #{invoice_id} reçue via AS4 depuis une PA distante, pytestbdd_stepdef_then_PEPPOL retourne &quot;{error_code}&quot;, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint Chorus Pro via Pagero, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint de #{pa_id}, pytestbdd_stepdef_then_j'obtiens &quot;{result}&quot;, pytestbdd_stepdef_then_j'obtiens l'URL du SMP &quot;{smp_url}&quot;, pytestbdd_stepdef_then_j'obtiens l'endpoint de la PA responsable, pytestbdd_stepdef_then_j'obtiens le code de retour {code}, pytestbdd_stepdef_then_j'obtiens le statut &quot;{status}&quot;, pytestbdd_stepdef_then_j'obtiens le statut #{status}, pytestbdd_stepdef_then_j'obtiens sur le canal 'healthcheck_resp' le message 'toto', pytestbdd_stepdef_then_j'obtiens sur le canal '{canal}' un message, pytestbdd_stepdef_then_j'obtiens un numéro de tâche, pytestbdd_stepdef_then_j'obtiens une erreur &quot;{error_code}&quot;, pytestbdd_stepdef_then_j'obtiens une erreur DNS &quot;{error}&quot;, pytestbdd_stepdef_then_j'obtiens une erreur HTTP {status_code:d}, pytestbdd_stepdef_then_j'obtiens une réponse DNS valide, pytestbdd_stepdef_then_j'obtiens une réponse SML valide, pytestbdd_stepdef_then_j'obtiens une réponse SMP valide, pytestbdd_stepdef_then_l'adresse de l'endpoint est &quot;{address}&quot;, pytestbdd_stepdef_then_l'endpoint AS4 est &quot;{endpoint}&quot;, pytestbdd_stepdef_then_l'identification par {facon} porte le code &quot;{code}&quot;, pytestbdd_stepdef_then_la destination est &quot;{destination}&quot;, pytestbdd_stepdef_then_la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL, pytestbdd_stepdef_then_la facture est livrée localement à #{enterprise_id}, pytestbdd_stepdef_then_la facture est livrée à #{enterprise_id}, pytestbdd_stepdef_then_la facture est mise en file d'attente pour retry, pytestbdd_stepdef_then_la facture est transmise au PPF, pytestbdd_stepdef_then_la facture est transmise au PPF_1, pytestbdd_stepdef_then_la facture est transmise au service de routage, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4_1, pytestbdd_stepdef_then_la facture est transmise à Chorus Pro, pytestbdd_stepdef_then_la facture est validée, pytestbdd_stepdef_then_la facture n'est PAS transmise au service de routage, pytestbdd_stepdef_then_la facture passe par l'annuaire local, pytestbdd_stepdef_then_la facture passe par le service de validation, pytestbdd_stepdef_then_la première tentative échoue, pytestbdd_stepdef_then_la requête SMP échoue avec HTTP {status_code:d}, pytestbdd_stepdef_then_la réponse SMP est signée, pytestbdd_stepdef_then_la résolution SML réussit, pytestbdd_stepdef_then_la seconde tentative réussit, pytestbdd_stepdef_then_la signature est valide, pytestbdd_stepdef_then_le certificat est au format X.509, pytestbdd_stepdef_then_le certificat est présent et valide, pytestbdd_stepdef_then_le certificat est signé par une autorité PEPPOL valide, pytestbdd_stepdef_then_le certificat n'est pas expiré, pytestbdd_stepdef_then_le certificat n'est pas révoqué, pytestbdd_stepdef_then_le code erreur est &quot;{error_code}&quot;, pytestbdd_stepdef_then_le destinataire #{enterprise_id} est trouvé localement, pytestbdd_stepdef_then_le destinataire #{enterprise_id} n'est pas trouvé localement, pytestbdd_stepdef_then_le hostname SML est &quot;B-{{hash}}.iso6523-actorid-upis.{sml_zone}&quot;, pytestbdd_stepdef_then_le lookup PEPPOL réussit, pytestbdd_stepdef_then_le lookup PEPPOL échoue, pytestbdd_stepdef_then_le message erreur contient &quot;{text}&quot;, pytestbdd_stepdef_then_le process identifier est &quot;{process_id}&quot;, pytestbdd_stepdef_then_le routage échoue définitivement, pytestbdd_stepdef_then_le service de routage consulte PEPPOL, pytestbdd_stepdef_then_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_then_le service de routage ne consulte PAS PEPPOL, pytestbdd_stepdef_then_le signataire est le SMP enregistré, pytestbdd_stepdef_then_le transport profile est &quot;{transport_profile}&quot;, pytestbdd_stepdef_then_les document types supportés incluent:, pytestbdd_stepdef_then_trace, pytestbdd_stepdef_then_un accusé de réception AS4 est envoyé, pytestbdd_stepdef_then_un message d'erreur est publié sur &quot;{channel}&quot;, pytestbdd_stepdef_then_une seconde tentative est programmée après {delay:d} secondes, pytestbdd_stepdef_when_j'appele l'API {verb} {path}, pytestbdd_stepdef_when_j'interroge la tâche, pytestbdd_stepdef_when_j'interroge le SML via DNS, pytestbdd_stepdef_when_j'écoute le canal '{canal}', pytestbdd_stepdef_when_je calcule l'empreinte md5 de &quot;{msg}&quot;, pytestbdd_stepdef_when_je calcule l'empreinte {facon} &quot;{id}&quot;, pytestbdd_stepdef_when_je calcule l'hôte SML pour {facon} &quot;{id}&quot;, pytestbdd_stepdef_when_je définis un contrôle de conformité métier fournisseur, pytestbdd_stepdef_when_je dépose la facture #{invoice_id}, pytestbdd_stepdef_when_je dépose la facture #{invoice} sur #{pa}, pytestbdd_stepdef_when_je dépose pour contrôle la facture @{invoice}, pytestbdd_stepdef_when_je dépose une facture, pytestbdd_stepdef_when_je publie le message '{msg}' sur le canal '{canal}', pytestbdd_stepdef_when_je recherche le participant PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIREN &quot;{siren}&quot;, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_when_je recherche les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère la liste des document types pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_l'adresse de contrôle &quot;{url}&quot;, pytestbdd_stepdef_when_la PA #{pa_id} reçoit la facture #{invoice_id} via AS4, pytestbdd_stepdef_when_la requête DNS prend plus de {timeout:d} secondes, pytestbdd_stepdef_when_le document type est &quot;{doc_type}&quot;, pytestbdd_stepdef_when_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_trace, pytestbdd_stepdef_when_un utilisateur de #{pa_id} dépose la facture #{invoice_id}, pytestbdd_stepdef_when_{retries:d} tentatives échouent, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, user, world&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py:296">file /home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py, line 296
          def scenario_wrapper(request: FixtureRequest, _pytest_bdd_example: dict[str, str]) -&gt; Any:
E       fixture 'world1pac' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pytest_bdd_example, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, auth, author, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, doctest_namespace, event_loop_policy, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, monkeypatch, pac, peppol_context, peppol_service, pytestbdd_stepdef_given_#{enterprise_id} ne supporte que les factures UBL, pytestbdd_stepdef_given_#{entity_id} accessible via Chorus Pro sur PEPPOL, pytestbdd_stepdef_given_#{pa_id1} et #{pa_id2} enregistrées mutuellement sur PEPPOL, pytestbdd_stepdef_given_l'entité publique #{entity_id} avec le SIRET "{siret}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIREN "{siren}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIRET "{siret}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL avec scheme "{scheme}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id}, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id} via PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} non enregistrée sur PEPPOL, pytestbdd_stepdef_given_la PA #{pa_id}, pytestbdd_stepdef_given_la facture #{invoice_id} de #{sender_id} à #{recipient_id}, pytestbdd_stepdef_given_la racine SML "{zone}", pytestbdd_stepdef_given_le SML de test "{sml_zone}", pytestbdd_stepdef_given_le SMP de #{enterprise_id} accessible à "{smp_url}", pytestbdd_stepdef_given_le SMP de #{enterprise_id} disponible après {delay:d} secondes, pytestbdd_stepdef_given_le SMP de #{enterprise_id} définitivement indisponible, pytestbdd_stepdef_given_le SMP de #{enterprise_id} indisponible la première fois, pytestbdd_stepdef_given_le SMP de #{enterprise_id} temporairement indisponible (HTTP 503), pytestbdd_stepdef_given_le destinataire de #{invoice_id} est #{enterprise_id}, pytestbdd_stepdef_given_le service PEPPOL configuré en mode "{mode}", pytestbdd_stepdef_given_le service PEPPOL simulé avec:, pytestbdd_stepdef_given_trace, pytestbdd_stepdef_given_un SML de test lent, pytestbdd_stepdef_given_un timeout configuré à {timeout:d} secondes, pytestbdd_stepdef_given_un utilisateur, pytestbdd_stepdef_given_un utilisateur de la PA #{pa}, pytestbdd_stepdef_given_une facture #{invoice_id} reçue via AS4 depuis une PA distante, pytestbdd_stepdef_then_PEPPOL retourne "{error_code}", pytestbdd_stepdef_then_PEPPOL retourne l'endpoint Chorus Pro via Pagero, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint de #{pa_id}, pytestbdd_stepdef_then_j'obtiens "{result}", pytestbdd_stepdef_then_j'obtiens l'URL du SMP "{smp_url}", pytestbdd_stepdef_then_j'obtiens l'endpoint de la PA responsable, pytestbdd_stepdef_then_j'obtiens le code de retour {code}, pytestbdd_stepdef_then_j'obtiens le statut "{status}", pytestbdd_stepdef_then_j'obtiens le statut #{status}, pytestbdd_stepdef_then_j'obtiens sur le canal 'healthcheck_resp' le message 'toto', pytestbdd_stepdef_then_j'obtiens sur le canal '{canal}' un message, pytestbdd_stepdef_then_j'obtiens un numéro de tâche, pytestbdd_stepdef_then_j'obtiens une erreur "{error_code}", pytestbdd_stepdef_then_j'obtiens une erreur DNS "{error}", pytestbdd_stepdef_then_j'obtiens une erreur HTTP {status_code:d}, pytestbdd_stepdef_then_j'obtiens une réponse DNS valide, pytestbdd_stepdef_then_j'obtiens une réponse SML valide, pytestbdd_stepdef_then_j'obtiens une réponse SMP valide, pytestbdd_stepdef_then_l'adresse de l'endpoint est "{address}", pytestbdd_stepdef_then_l'endpoint AS4 est "{endpoint}", pytestbdd_stepdef_then_l'identification par {facon} porte le code "{code}", pytestbdd_stepdef_then_la destination est "{destination}", pytestbdd_stepdef_then_la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL, pytestbdd_stepdef_then_la facture est livrée localement à #{enterprise_id}, pytestbdd_stepdef_then_la facture est livrée à #{enterprise_id}, pytestbdd_stepdef_then_la facture est mise en file d'attente pour retry, pytestbdd_stepdef_then_la facture est transmise au PPF, pytestbdd_stepdef_then_la facture est transmise au PPF_1, pytestbdd_stepdef_then_la facture est transmise au service de routage, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4_1, pytestbdd_stepdef_then_la facture est transmise à Chorus Pro, pytestbdd_stepdef_then_la facture est validée, pytestbdd_stepdef_then_la facture n'est PAS transmise au service de routage, pytestbdd_stepdef_then_la facture passe par l'annuaire local, pytestbdd_stepdef_then_la facture passe par le service de validation, pytestbdd_stepdef_then_la première tentative échoue, pytestbdd_stepdef_then_la requête SMP échoue avec HTTP {status_code:d}, pytestbdd_stepdef_then_la réponse SMP est signée, pytestbdd_stepdef_then_la résolution SML réussit, pytestbdd_stepdef_then_la seconde tentative réussit, pytestbdd_stepdef_then_la signature est valide, pytestbdd_stepdef_then_le certificat est au format X.509, pytestbdd_stepdef_then_le certificat est présent et valide, pytestbdd_stepdef_then_le certificat est signé par une autorité PEPPOL valide, pytestbdd_stepdef_then_le certificat n'est pas expiré, pytestbdd_stepdef_then_le certificat n'est pas révoqué, pytestbdd_stepdef_then_le code erreur est "{error_code}", pytestbdd_stepdef_then_le destinataire #{enterprise_id} est trouvé localement, pytestbdd_stepdef_then_le destinataire #{enterprise_id} n'est pas trouvé localement, pytestbdd_stepdef_then_le hostname SML est "B-{{hash}}.iso6523-actorid-upis.{sml_zone}", pytestbdd_stepdef_then_le lookup PEPPOL réussit, pytestbdd_stepdef_then_le lookup PEPPOL échoue, pytestbdd_stepdef_then_le message erreur contient "{text}", pytestbdd_stepdef_then_le process identifier est "{process_id}", pytestbdd_stepdef_then_le routage échoue définitivement, pytestbdd_stepdef_then_le service de routage consulte PEPPOL, pytestbdd_stepdef_then_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_then_le service de routage ne consulte PAS PEPPOL, pytestbdd_stepdef_then_le signataire est le SMP enregistré, pytestbdd_stepdef_then_le transport profile est "{transport_profile}", pytestbdd_stepdef_then_les document types supportés incluent:, pytestbdd_stepdef_then_trace, pytestbdd_stepdef_then_un accusé de réception AS4 est envoyé, pytestbdd_stepdef_then_un message d'erreur est publié sur "{channel}", pytestbdd_stepdef_then_une seconde tentative est programmée après {delay:d} secondes, pytestbdd_stepdef_when_j'appele l'API {verb} {path}, pytestbdd_stepdef_when_j'interroge la tâche, pytestbdd_stepdef_when_j'interroge le SML via DNS, pytestbdd_stepdef_when_j'écoute le canal '{canal}', pytestbdd_stepdef_when_je calcule l'empreinte md5 de "{msg}", pytestbdd_stepdef_when_je calcule l'empreinte {facon} "{id}", pytestbdd_stepdef_when_je calcule l'hôte SML pour {facon} "{id}", pytestbdd_stepdef_when_je définis un contrôle de conformité métier fournisseur, pytestbdd_stepdef_when_je dépose la facture #{invoice_id}, pytestbdd_stepdef_when_je dépose la facture #{invoice} sur #{pa}, pytestbdd_stepdef_when_je dépose pour contrôle la facture @{invoice}, pytestbdd_stepdef_when_je dépose une facture, pytestbdd_stepdef_when_je publie le message '{msg}' sur le canal '{canal}', pytestbdd_stepdef_when_je recherche le participant PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIREN "{siren}", pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIRET "{siret}", pytestbdd_stepdef_when_je recherche les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère la liste des document types pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_l'adresse de contrôle "{url}", pytestbdd_stepdef_when_la PA #{pa_id} reçoit la facture #{invoice_id} via AS4, pytestbdd_stepdef_when_la requête DNS prend plus de {timeout:d} secondes, pytestbdd_stepdef_when_le document type est "{doc_type}", pytestbdd_stepdef_when_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_trace, pytestbdd_stepdef_when_un utilisateur de #{pa_id} dépose la facture #{invoice_id}, pytestbdd_stepdef_when_{retries:d} tentatives échouent, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, user, world
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py:296</failure></testcase><testcase classname="test_scenario" name="test_trackingid_absent" time="0.000"><failure message="file /home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py, line 296&#10;          def scenario_wrapper(request: FixtureRequest, _pytest_bdd_example: dict[str, str]) -&gt; Any:&#10;E       fixture 'world1pac' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pytest_bdd_example, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, auth, author, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, doctest_namespace, event_loop_policy, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, monkeypatch, pac, peppol_context, peppol_service, pytestbdd_stepdef_given_#{enterprise_id} ne supporte que les factures UBL, pytestbdd_stepdef_given_#{entity_id} accessible via Chorus Pro sur PEPPOL, pytestbdd_stepdef_given_#{pa_id1} et #{pa_id2} enregistrées mutuellement sur PEPPOL, pytestbdd_stepdef_given_l'entité publique #{entity_id} avec le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIREN &quot;{siren}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL avec scheme &quot;{scheme}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id}, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id} via PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} non enregistrée sur PEPPOL, pytestbdd_stepdef_given_la PA #{pa_id}, pytestbdd_stepdef_given_la facture #{invoice_id} de #{sender_id} à #{recipient_id}, pytestbdd_stepdef_given_la racine SML &quot;{zone}&quot;, pytestbdd_stepdef_given_le SML de test &quot;{sml_zone}&quot;, pytestbdd_stepdef_given_le SMP de #{enterprise_id} accessible à &quot;{smp_url}&quot;, pytestbdd_stepdef_given_le SMP de #{enterprise_id} disponible après {delay:d} secondes, pytestbdd_stepdef_given_le SMP de #{enterprise_id} définitivement indisponible, pytestbdd_stepdef_given_le SMP de #{enterprise_id} indisponible la première fois, pytestbdd_stepdef_given_le SMP de #{enterprise_id} temporairement indisponible (HTTP 503), pytestbdd_stepdef_given_le destinataire de #{invoice_id} est #{enterprise_id}, pytestbdd_stepdef_given_le service PEPPOL configuré en mode &quot;{mode}&quot;, pytestbdd_stepdef_given_le service PEPPOL simulé avec:, pytestbdd_stepdef_given_trace, pytestbdd_stepdef_given_un SML de test lent, pytestbdd_stepdef_given_un timeout configuré à {timeout:d} secondes, pytestbdd_stepdef_given_un utilisateur, pytestbdd_stepdef_given_un utilisateur de la PA #{pa}, pytestbdd_stepdef_given_une facture #{invoice_id} reçue via AS4 depuis une PA distante, pytestbdd_stepdef_then_PEPPOL retourne &quot;{error_code}&quot;, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint Chorus Pro via Pagero, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint de #{pa_id}, pytestbdd_stepdef_then_j'obtiens &quot;{result}&quot;, pytestbdd_stepdef_then_j'obtiens l'URL du SMP &quot;{smp_url}&quot;, pytestbdd_stepdef_then_j'obtiens l'endpoint de la PA responsable, pytestbdd_stepdef_then_j'obtiens le code de retour {code}, pytestbdd_stepdef_then_j'obtiens le statut &quot;{status}&quot;, pytestbdd_stepdef_then_j'obtiens le statut #{status}, pytestbdd_stepdef_then_j'obtiens sur le canal 'healthcheck_resp' le message 'toto', pytestbdd_stepdef_then_j'obtiens sur le canal '{canal}' un message, pytestbdd_stepdef_then_j'obtiens un numéro de tâche, pytestbdd_stepdef_then_j'obtiens une erreur &quot;{error_code}&quot;, pytestbdd_stepdef_then_j'obtiens une erreur DNS &quot;{error}&quot;, pytestbdd_stepdef_then_j'obtiens une erreur HTTP {status_code:d}, pytestbdd_stepdef_then_j'obtiens une réponse DNS valide, pytestbdd_stepdef_then_j'obtiens une réponse SML valide, pytestbdd_stepdef_then_j'obtiens une réponse SMP valide, pytestbdd_stepdef_then_l'adresse de l'endpoint est &quot;{address}&quot;, pytestbdd_stepdef_then_l'endpoint AS4 est &quot;{endpoint}&quot;, pytestbdd_stepdef_then_l'identification par {facon} porte le code &quot;{code}&quot;, pytestbdd_stepdef_then_la destination est &quot;{destination}&quot;, pytestbdd_stepdef_then_la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL, pytestbdd_stepdef_then_la facture est livrée localement à #{enterprise_id}, pytestbdd_stepdef_then_la facture est livrée à #{enterprise_id}, pytestbdd_stepdef_then_la facture est mise en file d'attente pour retry, pytestbdd_stepdef_then_la facture est transmise au PPF, pytestbdd_stepdef_then_la facture est transmise au PPF_1, pytestbdd_stepdef_then_la facture est transmise au service de routage, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4_1, pytestbdd_stepdef_then_la facture est transmise à Chorus Pro, pytestbdd_stepdef_then_la facture est validée, pytestbdd_stepdef_then_la facture n'est PAS transmise au service de routage, pytestbdd_stepdef_then_la facture passe par l'annuaire local, pytestbdd_stepdef_then_la facture passe par le service de validation, pytestbdd_stepdef_then_la première tentative échoue, pytestbdd_stepdef_then_la requête SMP échoue avec HTTP {status_code:d}, pytestbdd_stepdef_then_la réponse SMP est signée, pytestbdd_stepdef_then_la résolution SML réussit, pytestbdd_stepdef_then_la seconde tentative réussit, pytestbdd_stepdef_then_la signature est valide, pytestbdd_stepdef_then_le certificat est au format X.509, pytestbdd_stepdef_then_le certificat est présent et valide, pytestbdd_stepdef_then_le certificat est signé par une autorité PEPPOL valide, pytestbdd_stepdef_then_le certificat n'est pas expiré, pytestbdd_stepdef_then_le certificat n'est pas révoqué, pytestbdd_stepdef_then_le code erreur est &quot;{error_code}&quot;, pytestbdd_stepdef_then_le destinataire #{enterprise_id} est trouvé localement, pytestbdd_stepdef_then_le destinataire #{enterprise_id} n'est pas trouvé localement, pytestbdd_stepdef_then_le hostname SML est &quot;B-{{hash}}.iso6523-actorid-upis.{sml_zone}&quot;, pytestbdd_stepdef_then_le lookup PEPPOL réussit, pytestbdd_stepdef_then_le lookup PEPPOL échoue, pytestbdd_stepdef_then_le message erreur contient &quot;{text}&quot;, pytestbdd_stepdef_then_le process identifier est &quot;{process_id}&quot;, pytestbdd_stepdef_then_le routage échoue définitivement, pytestbdd_stepdef_then_le service de routage consulte PEPPOL, pytestbdd_stepdef_then_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_then_le service de routage ne consulte PAS PEPPOL, pytestbdd_stepdef_then_le signataire est le SMP enregistré, pytestbdd_stepdef_then_le transport profile est &quot;{transport_profile}&quot;, pytestbdd_stepdef_then_les document types supportés incluent:, pytestbdd_stepdef_then_trace, pytestbdd_stepdef_then_un accusé de réception AS4 est envoyé, pytestbdd_stepdef_then_un message d'erreur est publié sur &quot;{channel}&quot;, pytestbdd_stepdef_then_une seconde tentative est programmée après {delay:d} secondes, pytestbdd_stepdef_when_j'appele l'API {verb} {path}, pytestbdd_stepdef_when_j'interroge la tâche, pytestbdd_stepdef_when_j'interroge le SML via DNS, pytestbdd_stepdef_when_j'écoute le canal '{canal}', pytestbdd_stepdef_when_je calcule l'empreinte md5 de &quot;{msg}&quot;, pytestbdd_stepdef_when_je calcule l'empreinte {facon} &quot;{id}&quot;, pytestbdd_stepdef_when_je calcule l'hôte SML pour {facon} &quot;{id}&quot;, pytestbdd_stepdef_when_je définis un contrôle de conformité métier fournisseur, pytestbdd_stepdef_when_je dépose la facture #{invoice_id}, pytestbdd_stepdef_when_je dépose la facture #{invoice} sur #{pa}, pytestbdd_stepdef_when_je dépose pour contrôle la facture @{invoice}, pytestbdd_stepdef_when_je dépose une facture, pytestbdd_stepdef_when_je publie le message '{msg}' sur le canal '{canal}', pytestbdd_stepdef_when_je recherche le participant PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIREN &quot;{siren}&quot;, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_when_je recherche les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère la liste des document types pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_l'adresse de contrôle &quot;{url}&quot;, pytestbdd_stepdef_when_la PA #{pa_id} reçoit la facture #{invoice_id} via AS4, pytestbdd_stepdef_when_la requête DNS prend plus de {timeout:d} secondes, pytestbdd_stepdef_when_le document type est &quot;{doc_type}&quot;, pytestbdd_stepdef_when_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_trace, pytestbdd_stepdef_when_un utilisateur de #{pa_id} dépose la facture #{invoice_id}, pytestbdd_stepdef_when_{retries:d} tentatives échouent, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, user, world&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py:296">file /home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py, line 296
          def scenario_wrapper(request: FixtureRequest, _pytest_bdd_example: dict[str, str]) -&gt; Any:
E       fixture 'world1pac' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pytest_bdd_example, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, auth, author, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, doctest_namespace, event_loop_policy, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, monkeypatch, pac, peppol_context, peppol_service, pytestbdd_stepdef_given_#{enterprise_id} ne supporte que les factures UBL, pytestbdd_stepdef_given_#{entity_id} accessible via Chorus Pro sur PEPPOL, pytestbdd_stepdef_given_#{pa_id1} et #{pa_id2} enregistrées mutuellement sur PEPPOL, pytestbdd_stepdef_given_l'entité publique #{entity_id} avec le SIRET "{siret}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIREN "{siren}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIRET "{siret}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL avec scheme "{scheme}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id}, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id} via PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} non enregistrée sur PEPPOL, pytestbdd_stepdef_given_la PA #{pa_id}, pytestbdd_stepdef_given_la facture #{invoice_id} de #{sender_id} à #{recipient_id}, pytestbdd_stepdef_given_la racine SML "{zone}", pytestbdd_stepdef_given_le SML de test "{sml_zone}", pytestbdd_stepdef_given_le SMP de #{enterprise_id} accessible à "{smp_url}", pytestbdd_stepdef_given_le SMP de #{enterprise_id} disponible après {delay:d} secondes, pytestbdd_stepdef_given_le SMP de #{enterprise_id} définitivement indisponible, pytestbdd_stepdef_given_le SMP de #{enterprise_id} indisponible la première fois, pytestbdd_stepdef_given_le SMP de #{enterprise_id} temporairement indisponible (HTTP 503), pytestbdd_stepdef_given_le destinataire de #{invoice_id} est #{enterprise_id}, pytestbdd_stepdef_given_le service PEPPOL configuré en mode "{mode}", pytestbdd_stepdef_given_le service PEPPOL simulé avec:, pytestbdd_stepdef_given_trace, pytestbdd_stepdef_given_un SML de test lent, pytestbdd_stepdef_given_un timeout configuré à {timeout:d} secondes, pytestbdd_stepdef_given_un utilisateur, pytestbdd_stepdef_given_un utilisateur de la PA #{pa}, pytestbdd_stepdef_given_une facture #{invoice_id} reçue via AS4 depuis une PA distante, pytestbdd_stepdef_then_PEPPOL retourne "{error_code}", pytestbdd_stepdef_then_PEPPOL retourne l'endpoint Chorus Pro via Pagero, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint de #{pa_id}, pytestbdd_stepdef_then_j'obtiens "{result}", pytestbdd_stepdef_then_j'obtiens l'URL du SMP "{smp_url}", pytestbdd_stepdef_then_j'obtiens l'endpoint de la PA responsable, pytestbdd_stepdef_then_j'obtiens le code de retour {code}, pytestbdd_stepdef_then_j'obtiens le statut "{status}", pytestbdd_stepdef_then_j'obtiens le statut #{status}, pytestbdd_stepdef_then_j'obtiens sur le canal 'healthcheck_resp' le message 'toto', pytestbdd_stepdef_then_j'obtiens sur le canal '{canal}' un message, pytestbdd_stepdef_then_j'obtiens un numéro de tâche, pytestbdd_stepdef_then_j'obtiens une erreur "{error_code}", pytestbdd_stepdef_then_j'obtiens une erreur DNS "{error}", pytestbdd_stepdef_then_j'obtiens une erreur HTTP {status_code:d}, pytestbdd_stepdef_then_j'obtiens une réponse DNS valide, pytestbdd_stepdef_then_j'obtiens une réponse SML valide, pytestbdd_stepdef_then_j'obtiens une réponse SMP valide, pytestbdd_stepdef_then_l'adresse de l'endpoint est "{address}", pytestbdd_stepdef_then_l'endpoint AS4 est "{endpoint}", pytestbdd_stepdef_then_l'identification par {facon} porte le code "{code}", pytestbdd_stepdef_then_la destination est "{destination}", pytestbdd_stepdef_then_la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL, pytestbdd_stepdef_then_la facture est livrée localement à #{enterprise_id}, pytestbdd_stepdef_then_la facture est livrée à #{enterprise_id}, pytestbdd_stepdef_then_la facture est mise en file d'attente pour retry, pytestbdd_stepdef_then_la facture est transmise au PPF, pytestbdd_stepdef_then_la facture est transmise au PPF_1, pytestbdd_stepdef_then_la facture est transmise au service de routage, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4_1, pytestbdd_stepdef_then_la facture est transmise à Chorus Pro, pytestbdd_stepdef_then_la facture est validée, pytestbdd_stepdef_then_la facture n'est PAS transmise au service de routage, pytestbdd_stepdef_then_la facture passe par l'annuaire local, pytestbdd_stepdef_then_la facture passe par le service de validation, pytestbdd_stepdef_then_la première tentative échoue, pytestbdd_stepdef_then_la requête SMP échoue avec HTTP {status_code:d}, pytestbdd_stepdef_then_la réponse SMP est signée, pytestbdd_stepdef_then_la résolution SML réussit, pytestbdd_stepdef_then_la seconde tentative réussit, pytestbdd_stepdef_then_la signature est valide, pytestbdd_stepdef_then_le certificat est au format X.509, pytestbdd_stepdef_then_le certificat est présent et valide, pytestbdd_stepdef_then_le certificat est signé par une autorité PEPPOL valide, pytestbdd_stepdef_then_le certificat n'est pas expiré, pytestbdd_stepdef_then_le certificat n'est pas révoqué, pytestbdd_stepdef_then_le code erreur est "{error_code}", pytestbdd_stepdef_then_le destinataire #{enterprise_id} est trouvé localement, pytestbdd_stepdef_then_le destinataire #{enterprise_id} n'est pas trouvé localement, pytestbdd_stepdef_then_le hostname SML est "B-{{hash}}.iso6523-actorid-upis.{sml_zone}", pytestbdd_stepdef_then_le lookup PEPPOL réussit, pytestbdd_stepdef_then_le lookup PEPPOL échoue, pytestbdd_stepdef_then_le message erreur contient "{text}", pytestbdd_stepdef_then_le process identifier est "{process_id}", pytestbdd_stepdef_then_le routage échoue définitivement, pytestbdd_stepdef_then_le service de routage consulte PEPPOL, pytestbdd_stepdef_then_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_then_le service de routage ne consulte PAS PEPPOL, pytestbdd_stepdef_then_le signataire est le SMP enregistré, pytestbdd_stepdef_then_le transport profile est "{transport_profile}", pytestbdd_stepdef_then_les document types supportés incluent:, pytestbdd_stepdef_then_trace, pytestbdd_stepdef_then_un accusé de réception AS4 est envoyé, pytestbdd_stepdef_then_un message d'erreur est publié sur "{channel}", pytestbdd_stepdef_then_une seconde tentative est programmée après {delay:d} secondes, pytestbdd_stepdef_when_j'appele l'API {verb} {path}, pytestbdd_stepdef_when_j'interroge la tâche, pytestbdd_stepdef_when_j'interroge le SML via DNS, pytestbdd_stepdef_when_j'écoute le canal '{canal}', pytestbdd_stepdef_when_je calcule l'empreinte md5 de "{msg}", pytestbdd_stepdef_when_je calcule l'empreinte {facon} "{id}", pytestbdd_stepdef_when_je calcule l'hôte SML pour {facon} "{id}", pytestbdd_stepdef_when_je définis un contrôle de conformité métier fournisseur, pytestbdd_stepdef_when_je dépose la facture #{invoice_id}, pytestbdd_stepdef_when_je dépose la facture #{invoice} sur #{pa}, pytestbdd_stepdef_when_je dépose pour contrôle la facture @{invoice}, pytestbdd_stepdef_when_je dépose une facture, pytestbdd_stepdef_when_je publie le message '{msg}' sur le canal '{canal}', pytestbdd_stepdef_when_je recherche le participant PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIREN "{siren}", pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIRET "{siret}", pytestbdd_stepdef_when_je recherche les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère la liste des document types pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_l'adresse de contrôle "{url}", pytestbdd_stepdef_when_la PA #{pa_id} reçoit la facture #{invoice_id} via AS4, pytestbdd_stepdef_when_la requête DNS prend plus de {timeout:d} secondes, pytestbdd_stepdef_when_le document type est "{doc_type}", pytestbdd_stepdef_when_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_trace, pytestbdd_stepdef_when_un utilisateur de #{pa_id} dépose la facture #{invoice_id}, pytestbdd_stepdef_when_{retries:d} tentatives échouent, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, user, world
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py:296</failure></testcase><testcase classname="test_scenario" name="test_trackingid_doublon" time="0.000"><failure message="file /home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py, line 296&#10;          def scenario_wrapper(request: FixtureRequest, _pytest_bdd_example: dict[str, str]) -&gt; Any:&#10;E       fixture 'world1pac' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pytest_bdd_example, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, auth, author, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, doctest_namespace, event_loop_policy, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, monkeypatch, pac, peppol_context, peppol_service, pytestbdd_stepdef_given_#{enterprise_id} ne supporte que les factures UBL, pytestbdd_stepdef_given_#{entity_id} accessible via Chorus Pro sur PEPPOL, pytestbdd_stepdef_given_#{pa_id1} et #{pa_id2} enregistrées mutuellement sur PEPPOL, pytestbdd_stepdef_given_l'entité publique #{entity_id} avec le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIREN &quot;{siren}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL avec scheme &quot;{scheme}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id}, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id} via PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} non enregistrée sur PEPPOL, pytestbdd_stepdef_given_la PA #{pa_id}, pytestbdd_stepdef_given_la facture #{invoice_id} de #{sender_id} à #{recipient_id}, pytestbdd_stepdef_given_la racine SML &quot;{zone}&quot;, pytestbdd_stepdef_given_le SML de test &quot;{sml_zone}&quot;, pytestbdd_stepdef_given_le SMP de #{enterprise_id} accessible à &quot;{smp_url}&quot;, pytestbdd_stepdef_given_le SMP de #{enterprise_id} disponible après {delay:d} secondes, pytestbdd_stepdef_given_le SMP de #{enterprise_id} définitivement indisponible, pytestbdd_stepdef_given_le SMP de #{enterprise_id} indisponible la première fois, pytestbdd_stepdef_given_le SMP de #{enterprise_id} temporairement indisponible (HTTP 503), pytestbdd_stepdef_given_le destinataire de #{invoice_id} est #{enterprise_id}, pytestbdd_stepdef_given_le service PEPPOL configuré en mode &quot;{mode}&quot;, pytestbdd_stepdef_given_le service PEPPOL simulé avec:, pytestbdd_stepdef_given_trace, pytestbdd_stepdef_given_un SML de test lent, pytestbdd_stepdef_given_un timeout configuré à {timeout:d} secondes, pytestbdd_stepdef_given_un utilisateur, pytestbdd_stepdef_given_un utilisateur de la PA #{pa}, pytestbdd_stepdef_given_une facture #{invoice_id} reçue via AS4 depuis une PA distante, pytestbdd_stepdef_then_PEPPOL retourne &quot;{error_code}&quot;, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint Chorus Pro via Pagero, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint de #{pa_id}, pytestbdd_stepdef_then_j'obtiens &quot;{result}&quot;, pytestbdd_stepdef_then_j'obtiens l'URL du SMP &quot;{smp_url}&quot;, pytestbdd_stepdef_then_j'obtiens l'endpoint de la PA responsable, pytestbdd_stepdef_then_j'obtiens le code de retour {code}, pytestbdd_stepdef_then_j'obtiens le statut &quot;{status}&quot;, pytestbdd_stepdef_then_j'obtiens le statut #{status}, pytestbdd_stepdef_then_j'obtiens sur le canal 'healthcheck_resp' le message 'toto', pytestbdd_stepdef_then_j'obtiens sur le canal '{canal}' un message, pytestbdd_stepdef_then_j'obtiens un numéro de tâche, pytestbdd_stepdef_then_j'obtiens une erreur &quot;{error_code}&quot;, pytestbdd_stepdef_then_j'obtiens une erreur DNS &quot;{error}&quot;, pytestbdd_stepdef_then_j'obtiens une erreur HTTP {status_code:d}, pytestbdd_stepdef_then_j'obtiens une réponse DNS valide, pytestbdd_stepdef_then_j'obtiens une réponse SML valide, pytestbdd_stepdef_then_j'obtiens une réponse SMP valide, pytestbdd_stepdef_then_l'adresse de l'endpoint est &quot;{address}&quot;, pytestbdd_stepdef_then_l'endpoint AS4 est &quot;{endpoint}&quot;, pytestbdd_stepdef_then_l'identification par {facon} porte le code &quot;{code}&quot;, pytestbdd_stepdef_then_la destination est &quot;{destination}&quot;, pytestbdd_stepdef_then_la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL, pytestbdd_stepdef_then_la facture est livrée localement à #{enterprise_id}, pytestbdd_stepdef_then_la facture est livrée à #{enterprise_id}, pytestbdd_stepdef_then_la facture est mise en file d'attente pour retry, pytestbdd_stepdef_then_la facture est transmise au PPF, pytestbdd_stepdef_then_la facture est transmise au PPF_1, pytestbdd_stepdef_then_la facture est transmise au service de routage, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4_1, pytestbdd_stepdef_then_la facture est transmise à Chorus Pro, pytestbdd_stepdef_then_la facture est validée, pytestbdd_stepdef_then_la facture n'est PAS transmise au service de routage, pytestbdd_stepdef_then_la facture passe par l'annuaire local, pytestbdd_stepdef_then_la facture passe par le service de validation, pytestbdd_stepdef_then_la première tentative échoue, pytestbdd_stepdef_then_la requête SMP échoue avec HTTP {status_code:d}, pytestbdd_stepdef_then_la réponse SMP est signée, pytestbdd_stepdef_then_la résolution SML réussit, pytestbdd_stepdef_then_la seconde tentative réussit, pytestbdd_stepdef_then_la signature est valide, pytestbdd_stepdef_then_le certificat est au format X.509, pytestbdd_stepdef_then_le certificat est présent et valide, pytestbdd_stepdef_then_le certificat est signé par une autorité PEPPOL valide, pytestbdd_stepdef_then_le certificat n'est pas expiré, pytestbdd_stepdef_then_le certificat n'est pas révoqué, pytestbdd_stepdef_then_le code erreur est &quot;{error_code}&quot;, pytestbdd_stepdef_then_le destinataire #{enterprise_id} est trouvé localement, pytestbdd_stepdef_then_le destinataire #{enterprise_id} n'est pas trouvé localement, pytestbdd_stepdef_then_le hostname SML est &quot;B-{{hash}}.iso6523-actorid-upis.{sml_zone}&quot;, pytestbdd_stepdef_then_le lookup PEPPOL réussit, pytestbdd_stepdef_then_le lookup PEPPOL échoue, pytestbdd_stepdef_then_le message erreur contient &quot;{text}&quot;, pytestbdd_stepdef_then_le process identifier est &quot;{process_id}&quot;, pytestbdd_stepdef_then_le routage échoue définitivement, pytestbdd_stepdef_then_le service de routage consulte PEPPOL, pytestbdd_stepdef_then_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_then_le service de routage ne consulte PAS PEPPOL, pytestbdd_stepdef_then_le signataire est le SMP enregistré, pytestbdd_stepdef_then_le transport profile est &quot;{transport_profile}&quot;, pytestbdd_stepdef_then_les document types supportés incluent:, pytestbdd_stepdef_then_trace, pytestbdd_stepdef_then_un accusé de réception AS4 est envoyé, pytestbdd_stepdef_then_un message d'erreur est publié sur &quot;{channel}&quot;, pytestbdd_stepdef_then_une seconde tentative est programmée après {delay:d} secondes, pytestbdd_stepdef_when_j'appele l'API {verb} {path}, pytestbdd_stepdef_when_j'interroge la tâche, pytestbdd_stepdef_when_j'interroge le SML via DNS, pytestbdd_stepdef_when_j'écoute le canal '{canal}', pytestbdd_stepdef_when_je calcule l'empreinte md5 de &quot;{msg}&quot;, pytestbdd_stepdef_when_je calcule l'empreinte {facon} &quot;{id}&quot;, pytestbdd_stepdef_when_je calcule l'hôte SML pour {facon} &quot;{id}&quot;, pytestbdd_stepdef_when_je définis un contrôle de conformité métier fournisseur, pytestbdd_stepdef_when_je dépose la facture #{invoice_id}, pytestbdd_stepdef_when_je dépose la facture #{invoice} sur #{pa}, pytestbdd_stepdef_when_je dépose pour contrôle la facture @{invoice}, pytestbdd_stepdef_when_je dépose une facture, pytestbdd_stepdef_when_je publie le message '{msg}' sur le canal '{canal}', pytestbdd_stepdef_when_je recherche le participant PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIREN &quot;{siren}&quot;, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_when_je recherche les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère la liste des document types pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_l'adresse de contrôle &quot;{url}&quot;, pytestbdd_stepdef_when_la PA #{pa_id} reçoit la facture #{invoice_id} via AS4, pytestbdd_stepdef_when_la requête DNS prend plus de {timeout:d} secondes, pytestbdd_stepdef_when_le document type est &quot;{doc_type}&quot;, pytestbdd_stepdef_when_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_trace, pytestbdd_stepdef_when_un utilisateur de #{pa_id} dépose la facture #{invoice_id}, pytestbdd_stepdef_when_{retries:d} tentatives échouent, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, user, world&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py:296">file /home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py, line 296
          def scenario_wrapper(request: FixtureRequest, _pytest_bdd_example: dict[str, str]) -&gt; Any:
E       fixture 'world1pac' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pytest_bdd_example, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, auth, author, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, doctest_namespace, event_loop_policy, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, monkeypatch, pac, peppol_context, peppol_service, pytestbdd_stepdef_given_#{enterprise_id} ne supporte que les factures UBL, pytestbdd_stepdef_given_#{entity_id} accessible via Chorus Pro sur PEPPOL, pytestbdd_stepdef_given_#{pa_id1} et #{pa_id2} enregistrées mutuellement sur PEPPOL, pytestbdd_stepdef_given_l'entité publique #{entity_id} avec le SIRET "{siret}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIREN "{siren}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIRET "{siret}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL avec scheme "{scheme}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id}, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id} via PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} non enregistrée sur PEPPOL, pytestbdd_stepdef_given_la PA #{pa_id}, pytestbdd_stepdef_given_la facture #{invoice_id} de #{sender_id} à #{recipient_id}, pytestbdd_stepdef_given_la racine SML "{zone}", pytestbdd_stepdef_given_le SML de test "{sml_zone}", pytestbdd_stepdef_given_le SMP de #{enterprise_id} accessible à "{smp_url}", pytestbdd_stepdef_given_le SMP de #{enterprise_id} disponible après {delay:d} secondes, pytestbdd_stepdef_given_le SMP de #{enterprise_id} définitivement indisponible, pytestbdd_stepdef_given_le SMP de #{enterprise_id} indisponible la première fois, pytestbdd_stepdef_given_le SMP de #{enterprise_id} temporairement indisponible (HTTP 503), pytestbdd_stepdef_given_le destinataire de #{invoice_id} est #{enterprise_id}, pytestbdd_stepdef_given_le service PEPPOL configuré en mode "{mode}", pytestbdd_stepdef_given_le service PEPPOL simulé avec:, pytestbdd_stepdef_given_trace, pytestbdd_stepdef_given_un SML de test lent, pytestbdd_stepdef_given_un timeout configuré à {timeout:d} secondes, pytestbdd_stepdef_given_un utilisateur, pytestbdd_stepdef_given_un utilisateur de la PA #{pa}, pytestbdd_stepdef_given_une facture #{invoice_id} reçue via AS4 depuis une PA distante, pytestbdd_stepdef_then_PEPPOL retourne "{error_code}", pytestbdd_stepdef_then_PEPPOL retourne l'endpoint Chorus Pro via Pagero, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint de #{pa_id}, pytestbdd_stepdef_then_j'obtiens "{result}", pytestbdd_stepdef_then_j'obtiens l'URL du SMP "{smp_url}", pytestbdd_stepdef_then_j'obtiens l'endpoint de la PA responsable, pytestbdd_stepdef_then_j'obtiens le code de retour {code}, pytestbdd_stepdef_then_j'obtiens le statut "{status}", pytestbdd_stepdef_then_j'obtiens le statut #{status}, pytestbdd_stepdef_then_j'obtiens sur le canal 'healthcheck_resp' le message 'toto', pytestbdd_stepdef_then_j'obtiens sur le canal '{canal}' un message, pytestbdd_stepdef_then_j'obtiens un numéro de tâche, pytestbdd_stepdef_then_j'obtiens une erreur "{error_code}", pytestbdd_stepdef_then_j'obtiens une erreur DNS "{error}", pytestbdd_stepdef_then_j'obtiens une erreur HTTP {status_code:d}, pytestbdd_stepdef_then_j'obtiens une réponse DNS valide, pytestbdd_stepdef_then_j'obtiens une réponse SML valide, pytestbdd_stepdef_then_j'obtiens une réponse SMP valide, pytestbdd_stepdef_then_l'adresse de l'endpoint est "{address}", pytestbdd_stepdef_then_l'endpoint AS4 est "{endpoint}", pytestbdd_stepdef_then_l'identification par {facon} porte le code "{code}", pytestbdd_stepdef_then_la destination est "{destination}", pytestbdd_stepdef_then_la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL, pytestbdd_stepdef_then_la facture est livrée localement à #{enterprise_id}, pytestbdd_stepdef_then_la facture est livrée à #{enterprise_id}, pytestbdd_stepdef_then_la facture est mise en file d'attente pour retry, pytestbdd_stepdef_then_la facture est transmise au PPF, pytestbdd_stepdef_then_la facture est transmise au PPF_1, pytestbdd_stepdef_then_la facture est transmise au service de routage, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4_1, pytestbdd_stepdef_then_la facture est transmise à Chorus Pro, pytestbdd_stepdef_then_la facture est validée, pytestbdd_stepdef_then_la facture n'est PAS transmise au service de routage, pytestbdd_stepdef_then_la facture passe par l'annuaire local, pytestbdd_stepdef_then_la facture passe par le service de validation, pytestbdd_stepdef_then_la première tentative échoue, pytestbdd_stepdef_then_la requête SMP échoue avec HTTP {status_code:d}, pytestbdd_stepdef_then_la réponse SMP est signée, pytestbdd_stepdef_then_la résolution SML réussit, pytestbdd_stepdef_then_la seconde tentative réussit, pytestbdd_stepdef_then_la signature est valide, pytestbdd_stepdef_then_le certificat est au format X.509, pytestbdd_stepdef_then_le certificat est présent et valide, pytestbdd_stepdef_then_le certificat est signé par une autorité PEPPOL valide, pytestbdd_stepdef_then_le certificat n'est pas expiré, pytestbdd_stepdef_then_le certificat n'est pas révoqué, pytestbdd_stepdef_then_le code erreur est "{error_code}", pytestbdd_stepdef_then_le destinataire #{enterprise_id} est trouvé localement, pytestbdd_stepdef_then_le destinataire #{enterprise_id} n'est pas trouvé localement, pytestbdd_stepdef_then_le hostname SML est "B-{{hash}}.iso6523-actorid-upis.{sml_zone}", pytestbdd_stepdef_then_le lookup PEPPOL réussit, pytestbdd_stepdef_then_le lookup PEPPOL échoue, pytestbdd_stepdef_then_le message erreur contient "{text}", pytestbdd_stepdef_then_le process identifier est "{process_id}", pytestbdd_stepdef_then_le routage échoue définitivement, pytestbdd_stepdef_then_le service de routage consulte PEPPOL, pytestbdd_stepdef_then_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_then_le service de routage ne consulte PAS PEPPOL, pytestbdd_stepdef_then_le signataire est le SMP enregistré, pytestbdd_stepdef_then_le transport profile est "{transport_profile}", pytestbdd_stepdef_then_les document types supportés incluent:, pytestbdd_stepdef_then_trace, pytestbdd_stepdef_then_un accusé de réception AS4 est envoyé, pytestbdd_stepdef_then_un message d'erreur est publié sur "{channel}", pytestbdd_stepdef_then_une seconde tentative est programmée après {delay:d} secondes, pytestbdd_stepdef_when_j'appele l'API {verb} {path}, pytestbdd_stepdef_when_j'interroge la tâche, pytestbdd_stepdef_when_j'interroge le SML via DNS, pytestbdd_stepdef_when_j'écoute le canal '{canal}', pytestbdd_stepdef_when_je calcule l'empreinte md5 de "{msg}", pytestbdd_stepdef_when_je calcule l'empreinte {facon} "{id}", pytestbdd_stepdef_when_je calcule l'hôte SML pour {facon} "{id}", pytestbdd_stepdef_when_je définis un contrôle de conformité métier fournisseur, pytestbdd_stepdef_when_je dépose la facture #{invoice_id}, pytestbdd_stepdef_when_je dépose la facture #{invoice} sur #{pa}, pytestbdd_stepdef_when_je dépose pour contrôle la facture @{invoice}, pytestbdd_stepdef_when_je dépose une facture, pytestbdd_stepdef_when_je publie le message '{msg}' sur le canal '{canal}', pytestbdd_stepdef_when_je recherche le participant PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIREN "{siren}", pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIRET "{siret}", pytestbdd_stepdef_when_je recherche les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère la liste des document types pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_l'adresse de contrôle "{url}", pytestbdd_stepdef_when_la PA #{pa_id} reçoit la facture #{invoice_id} via AS4, pytestbdd_stepdef_when_la requête DNS prend plus de {timeout:d} secondes, pytestbdd_stepdef_when_le document type est "{doc_type}", pytestbdd_stepdef_when_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_trace, pytestbdd_stepdef_when_un utilisateur de #{pa_id} dépose la facture #{invoice_id}, pytestbdd_stepdef_when_{retries:d} tentatives échouent, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, user, world
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py:296</failure></testcase><testcase classname="test_scenario" name="test_contrôle_sha256" time="0.000"><failure message="file /home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py, line 296&#10;          def scenario_wrapper(request: FixtureRequest, _pytest_bdd_example: dict[str, str]) -&gt; Any:&#10;E       fixture 'world1pac' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pytest_bdd_example, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, auth, author, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, doctest_namespace, event_loop_policy, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, monkeypatch, pac, peppol_context, peppol_service, pytestbdd_stepdef_given_#{enterprise_id} ne supporte que les factures UBL, pytestbdd_stepdef_given_#{entity_id} accessible via Chorus Pro sur PEPPOL, pytestbdd_stepdef_given_#{pa_id1} et #{pa_id2} enregistrées mutuellement sur PEPPOL, pytestbdd_stepdef_given_l'entité publique #{entity_id} avec le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIREN &quot;{siren}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL avec scheme &quot;{scheme}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id}, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id} via PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} non enregistrée sur PEPPOL, pytestbdd_stepdef_given_la PA #{pa_id}, pytestbdd_stepdef_given_la facture #{invoice_id} de #{sender_id} à #{recipient_id}, pytestbdd_stepdef_given_la racine SML &quot;{zone}&quot;, pytestbdd_stepdef_given_le SML de test &quot;{sml_zone}&quot;, pytestbdd_stepdef_given_le SMP de #{enterprise_id} accessible à &quot;{smp_url}&quot;, pytestbdd_stepdef_given_le SMP de #{enterprise_id} disponible après {delay:d} secondes, pytestbdd_stepdef_given_le SMP de #{enterprise_id} définitivement indisponible, pytestbdd_stepdef_given_le SMP de #{enterprise_id} indisponible la première fois, pytestbdd_stepdef_given_le SMP de #{enterprise_id} temporairement indisponible (HTTP 503), pytestbdd_stepdef_given_le destinataire de #{invoice_id} est #{enterprise_id}, pytestbdd_stepdef_given_le service PEPPOL configuré en mode &quot;{mode}&quot;, pytestbdd_stepdef_given_le service PEPPOL simulé avec:, pytestbdd_stepdef_given_trace, pytestbdd_stepdef_given_un SML de test lent, pytestbdd_stepdef_given_un timeout configuré à {timeout:d} secondes, pytestbdd_stepdef_given_un utilisateur, pytestbdd_stepdef_given_un utilisateur de la PA #{pa}, pytestbdd_stepdef_given_une facture #{invoice_id} reçue via AS4 depuis une PA distante, pytestbdd_stepdef_then_PEPPOL retourne &quot;{error_code}&quot;, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint Chorus Pro via Pagero, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint de #{pa_id}, pytestbdd_stepdef_then_j'obtiens &quot;{result}&quot;, pytestbdd_stepdef_then_j'obtiens l'URL du SMP &quot;{smp_url}&quot;, pytestbdd_stepdef_then_j'obtiens l'endpoint de la PA responsable, pytestbdd_stepdef_then_j'obtiens le code de retour {code}, pytestbdd_stepdef_then_j'obtiens le statut &quot;{status}&quot;, pytestbdd_stepdef_then_j'obtiens le statut #{status}, pytestbdd_stepdef_then_j'obtiens sur le canal 'healthcheck_resp' le message 'toto', pytestbdd_stepdef_then_j'obtiens sur le canal '{canal}' un message, pytestbdd_stepdef_then_j'obtiens un numéro de tâche, pytestbdd_stepdef_then_j'obtiens une erreur &quot;{error_code}&quot;, pytestbdd_stepdef_then_j'obtiens une erreur DNS &quot;{error}&quot;, pytestbdd_stepdef_then_j'obtiens une erreur HTTP {status_code:d}, pytestbdd_stepdef_then_j'obtiens une réponse DNS valide, pytestbdd_stepdef_then_j'obtiens une réponse SML valide, pytestbdd_stepdef_then_j'obtiens une réponse SMP valide, pytestbdd_stepdef_then_l'adresse de l'endpoint est &quot;{address}&quot;, pytestbdd_stepdef_then_l'endpoint AS4 est &quot;{endpoint}&quot;, pytestbdd_stepdef_then_l'identification par {facon} porte le code &quot;{code}&quot;, pytestbdd_stepdef_then_la destination est &quot;{destination}&quot;, pytestbdd_stepdef_then_la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL, pytestbdd_stepdef_then_la facture est livrée localement à #{enterprise_id}, pytestbdd_stepdef_then_la facture est livrée à #{enterprise_id}, pytestbdd_stepdef_then_la facture est mise en file d'attente pour retry, pytestbdd_stepdef_then_la facture est transmise au PPF, pytestbdd_stepdef_then_la facture est transmise au PPF_1, pytestbdd_stepdef_then_la facture est transmise au service de routage, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4_1, pytestbdd_stepdef_then_la facture est transmise à Chorus Pro, pytestbdd_stepdef_then_la facture est validée, pytestbdd_stepdef_then_la facture n'est PAS transmise au service de routage, pytestbdd_stepdef_then_la facture passe par l'annuaire local, pytestbdd_stepdef_then_la facture passe par le service de validation, pytestbdd_stepdef_then_la première tentative échoue, pytestbdd_stepdef_then_la requête SMP échoue avec HTTP {status_code:d}, pytestbdd_stepdef_then_la réponse SMP est signée, pytestbdd_stepdef_then_la résolution SML réussit, pytestbdd_stepdef_then_la seconde tentative réussit, pytestbdd_stepdef_then_la signature est valide, pytestbdd_stepdef_then_le certificat est au format X.509, pytestbdd_stepdef_then_le certificat est présent et valide, pytestbdd_stepdef_then_le certificat est signé par une autorité PEPPOL valide, pytestbdd_stepdef_then_le certificat n'est pas expiré, pytestbdd_stepdef_then_le certificat n'est pas révoqué, pytestbdd_stepdef_then_le code erreur est &quot;{error_code}&quot;, pytestbdd_stepdef_then_le destinataire #{enterprise_id} est trouvé localement, pytestbdd_stepdef_then_le destinataire #{enterprise_id} n'est pas trouvé localement, pytestbdd_stepdef_then_le hostname SML est &quot;B-{{hash}}.iso6523-actorid-upis.{sml_zone}&quot;, pytestbdd_stepdef_then_le lookup PEPPOL réussit, pytestbdd_stepdef_then_le lookup PEPPOL échoue, pytestbdd_stepdef_then_le message erreur contient &quot;{text}&quot;, pytestbdd_stepdef_then_le process identifier est &quot;{process_id}&quot;, pytestbdd_stepdef_then_le routage échoue définitivement, pytestbdd_stepdef_then_le service de routage consulte PEPPOL, pytestbdd_stepdef_then_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_then_le service de routage ne consulte PAS PEPPOL, pytestbdd_stepdef_then_le signataire est le SMP enregistré, pytestbdd_stepdef_then_le transport profile est &quot;{transport_profile}&quot;, pytestbdd_stepdef_then_les document types supportés incluent:, pytestbdd_stepdef_then_trace, pytestbdd_stepdef_then_un accusé de réception AS4 est envoyé, pytestbdd_stepdef_then_un message d'erreur est publié sur &quot;{channel}&quot;, pytestbdd_stepdef_then_une seconde tentative est programmée après {delay:d} secondes, pytestbdd_stepdef_when_j'appele l'API {verb} {path}, pytestbdd_stepdef_when_j'interroge la tâche, pytestbdd_stepdef_when_j'interroge le SML via DNS, pytestbdd_stepdef_when_j'écoute le canal '{canal}', pytestbdd_stepdef_when_je calcule l'empreinte md5 de &quot;{msg}&quot;, pytestbdd_stepdef_when_je calcule l'empreinte {facon} &quot;{id}&quot;, pytestbdd_stepdef_when_je calcule l'hôte SML pour {facon} &quot;{id}&quot;, pytestbdd_stepdef_when_je définis un contrôle de conformité métier fournisseur, pytestbdd_stepdef_when_je dépose la facture #{invoice_id}, pytestbdd_stepdef_when_je dépose la facture #{invoice} sur #{pa}, pytestbdd_stepdef_when_je dépose pour contrôle la facture @{invoice}, pytestbdd_stepdef_when_je dépose une facture, pytestbdd_stepdef_when_je publie le message '{msg}' sur le canal '{canal}', pytestbdd_stepdef_when_je recherche le participant PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIREN &quot;{siren}&quot;, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_when_je recherche les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère la liste des document types pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_l'adresse de contrôle &quot;{url}&quot;, pytestbdd_stepdef_when_la PA #{pa_id} reçoit la facture #{invoice_id} via AS4, pytestbdd_stepdef_when_la requête DNS prend plus de {timeout:d} secondes, pytestbdd_stepdef_when_le document type est &quot;{doc_type}&quot;, pytestbdd_stepdef_when_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_trace, pytestbdd_stepdef_when_un utilisateur de #{pa_id} dépose la facture #{invoice_id}, pytestbdd_stepdef_when_{retries:d} tentatives échouent, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, user, world&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py:296">file /home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py, line 296
          def scenario_wrapper(request: FixtureRequest, _pytest_bdd_example: dict[str, str]) -&gt; Any:
E       fixture 'world1pac' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pytest_bdd_example, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, auth, author, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, doctest_namespace, event_loop_policy, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, monkeypatch, pac, peppol_context, peppol_service, pytestbdd_stepdef_given_#{enterprise_id} ne supporte que les factures UBL, pytestbdd_stepdef_given_#{entity_id} accessible via Chorus Pro sur PEPPOL, pytestbdd_stepdef_given_#{pa_id1} et #{pa_id2} enregistrées mutuellement sur PEPPOL, pytestbdd_stepdef_given_l'entité publique #{entity_id} avec le SIRET "{siret}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIREN "{siren}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIRET "{siret}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL avec scheme "{scheme}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id}, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id} via PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} non enregistrée sur PEPPOL, pytestbdd_stepdef_given_la PA #{pa_id}, pytestbdd_stepdef_given_la facture #{invoice_id} de #{sender_id} à #{recipient_id}, pytestbdd_stepdef_given_la racine SML "{zone}", pytestbdd_stepdef_given_le SML de test "{sml_zone}", pytestbdd_stepdef_given_le SMP de #{enterprise_id} accessible à "{smp_url}", pytestbdd_stepdef_given_le SMP de #{enterprise_id} disponible après {delay:d} secondes, pytestbdd_stepdef_given_le SMP de #{enterprise_id} définitivement indisponible, pytestbdd_stepdef_given_le SMP de #{enterprise_id} indisponible la première fois, pytestbdd_stepdef_given_le SMP de #{enterprise_id} temporairement indisponible (HTTP 503), pytestbdd_stepdef_given_le destinataire de #{invoice_id} est #{enterprise_id}, pytestbdd_stepdef_given_le service PEPPOL configuré en mode "{mode}", pytestbdd_stepdef_given_le service PEPPOL simulé avec:, pytestbdd_stepdef_given_trace, pytestbdd_stepdef_given_un SML de test lent, pytestbdd_stepdef_given_un timeout configuré à {timeout:d} secondes, pytestbdd_stepdef_given_un utilisateur, pytestbdd_stepdef_given_un utilisateur de la PA #{pa}, pytestbdd_stepdef_given_une facture #{invoice_id} reçue via AS4 depuis une PA distante, pytestbdd_stepdef_then_PEPPOL retourne "{error_code}", pytestbdd_stepdef_then_PEPPOL retourne l'endpoint Chorus Pro via Pagero, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint de #{pa_id}, pytestbdd_stepdef_then_j'obtiens "{result}", pytestbdd_stepdef_then_j'obtiens l'URL du SMP "{smp_url}", pytestbdd_stepdef_then_j'obtiens l'endpoint de la PA responsable, pytestbdd_stepdef_then_j'obtiens le code de retour {code}, pytestbdd_stepdef_then_j'obtiens le statut "{status}", pytestbdd_stepdef_then_j'obtiens le statut #{status}, pytestbdd_stepdef_then_j'obtiens sur le canal 'healthcheck_resp' le message 'toto', pytestbdd_stepdef_then_j'obtiens sur le canal '{canal}' un message, pytestbdd_stepdef_then_j'obtiens un numéro de tâche, pytestbdd_stepdef_then_j'obtiens une erreur "{error_code}", pytestbdd_stepdef_then_j'obtiens une erreur DNS "{error}", pytestbdd_stepdef_then_j'obtiens une erreur HTTP {status_code:d}, pytestbdd_stepdef_then_j'obtiens une réponse DNS valide, pytestbdd_stepdef_then_j'obtiens une réponse SML valide, pytestbdd_stepdef_then_j'obtiens une réponse SMP valide, pytestbdd_stepdef_then_l'adresse de l'endpoint est "{address}", pytestbdd_stepdef_then_l'endpoint AS4 est "{endpoint}", pytestbdd_stepdef_then_l'identification par {facon} porte le code "{code}", pytestbdd_stepdef_then_la destination est "{destination}", pytestbdd_stepdef_then_la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL, pytestbdd_stepdef_then_la facture est livrée localement à #{enterprise_id}, pytestbdd_stepdef_then_la facture est livrée à #{enterprise_id}, pytestbdd_stepdef_then_la facture est mise en file d'attente pour retry, pytestbdd_stepdef_then_la facture est transmise au PPF, pytestbdd_stepdef_then_la facture est transmise au PPF_1, pytestbdd_stepdef_then_la facture est transmise au service de routage, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4_1, pytestbdd_stepdef_then_la facture est transmise à Chorus Pro, pytestbdd_stepdef_then_la facture est validée, pytestbdd_stepdef_then_la facture n'est PAS transmise au service de routage, pytestbdd_stepdef_then_la facture passe par l'annuaire local, pytestbdd_stepdef_then_la facture passe par le service de validation, pytestbdd_stepdef_then_la première tentative échoue, pytestbdd_stepdef_then_la requête SMP échoue avec HTTP {status_code:d}, pytestbdd_stepdef_then_la réponse SMP est signée, pytestbdd_stepdef_then_la résolution SML réussit, pytestbdd_stepdef_then_la seconde tentative réussit, pytestbdd_stepdef_then_la signature est valide, pytestbdd_stepdef_then_le certificat est au format X.509, pytestbdd_stepdef_then_le certificat est présent et valide, pytestbdd_stepdef_then_le certificat est signé par une autorité PEPPOL valide, pytestbdd_stepdef_then_le certificat n'est pas expiré, pytestbdd_stepdef_then_le certificat n'est pas révoqué, pytestbdd_stepdef_then_le code erreur est "{error_code}", pytestbdd_stepdef_then_le destinataire #{enterprise_id} est trouvé localement, pytestbdd_stepdef_then_le destinataire #{enterprise_id} n'est pas trouvé localement, pytestbdd_stepdef_then_le hostname SML est "B-{{hash}}.iso6523-actorid-upis.{sml_zone}", pytestbdd_stepdef_then_le lookup PEPPOL réussit, pytestbdd_stepdef_then_le lookup PEPPOL échoue, pytestbdd_stepdef_then_le message erreur contient "{text}", pytestbdd_stepdef_then_le process identifier est "{process_id}", pytestbdd_stepdef_then_le routage échoue définitivement, pytestbdd_stepdef_then_le service de routage consulte PEPPOL, pytestbdd_stepdef_then_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_then_le service de routage ne consulte PAS PEPPOL, pytestbdd_stepdef_then_le signataire est le SMP enregistré, pytestbdd_stepdef_then_le transport profile est "{transport_profile}", pytestbdd_stepdef_then_les document types supportés incluent:, pytestbdd_stepdef_then_trace, pytestbdd_stepdef_then_un accusé de réception AS4 est envoyé, pytestbdd_stepdef_then_un message d'erreur est publié sur "{channel}", pytestbdd_stepdef_then_une seconde tentative est programmée après {delay:d} secondes, pytestbdd_stepdef_when_j'appele l'API {verb} {path}, pytestbdd_stepdef_when_j'interroge la tâche, pytestbdd_stepdef_when_j'interroge le SML via DNS, pytestbdd_stepdef_when_j'écoute le canal '{canal}', pytestbdd_stepdef_when_je calcule l'empreinte md5 de "{msg}", pytestbdd_stepdef_when_je calcule l'empreinte {facon} "{id}", pytestbdd_stepdef_when_je calcule l'hôte SML pour {facon} "{id}", pytestbdd_stepdef_when_je définis un contrôle de conformité métier fournisseur, pytestbdd_stepdef_when_je dépose la facture #{invoice_id}, pytestbdd_stepdef_when_je dépose la facture #{invoice} sur #{pa}, pytestbdd_stepdef_when_je dépose pour contrôle la facture @{invoice}, pytestbdd_stepdef_when_je dépose une facture, pytestbdd_stepdef_when_je publie le message '{msg}' sur le canal '{canal}', pytestbdd_stepdef_when_je recherche le participant PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIREN "{siren}", pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIRET "{siret}", pytestbdd_stepdef_when_je recherche les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère la liste des document types pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_l'adresse de contrôle "{url}", pytestbdd_stepdef_when_la PA #{pa_id} reçoit la facture #{invoice_id} via AS4, pytestbdd_stepdef_when_la requête DNS prend plus de {timeout:d} secondes, pytestbdd_stepdef_when_le document type est "{doc_type}", pytestbdd_stepdef_when_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_trace, pytestbdd_stepdef_when_un utilisateur de #{pa_id} dépose la facture #{invoice_id}, pytestbdd_stepdef_when_{retries:d} tentatives échouent, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, user, world
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py:296</failure></testcase><testcase classname="test_scenario" name="test_healthcheck_api_ok" time="0.000"><failure message="file /home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py, line 296&#10;          def scenario_wrapper(request: FixtureRequest, _pytest_bdd_example: dict[str, str]) -&gt; Any:&#10;E       fixture 'world1pac' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pytest_bdd_example, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, auth, author, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, doctest_namespace, event_loop_policy, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, monkeypatch, pac, peppol_context, peppol_service, pytestbdd_stepdef_given_#{enterprise_id} ne supporte que les factures UBL, pytestbdd_stepdef_given_#{entity_id} accessible via Chorus Pro sur PEPPOL, pytestbdd_stepdef_given_#{pa_id1} et #{pa_id2} enregistrées mutuellement sur PEPPOL, pytestbdd_stepdef_given_l'entité publique #{entity_id} avec le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIREN &quot;{siren}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL avec scheme &quot;{scheme}&quot;, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id}, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id} via PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} non enregistrée sur PEPPOL, pytestbdd_stepdef_given_la PA #{pa_id}, pytestbdd_stepdef_given_la facture #{invoice_id} de #{sender_id} à #{recipient_id}, pytestbdd_stepdef_given_la racine SML &quot;{zone}&quot;, pytestbdd_stepdef_given_le SML de test &quot;{sml_zone}&quot;, pytestbdd_stepdef_given_le SMP de #{enterprise_id} accessible à &quot;{smp_url}&quot;, pytestbdd_stepdef_given_le SMP de #{enterprise_id} disponible après {delay:d} secondes, pytestbdd_stepdef_given_le SMP de #{enterprise_id} définitivement indisponible, pytestbdd_stepdef_given_le SMP de #{enterprise_id} indisponible la première fois, pytestbdd_stepdef_given_le SMP de #{enterprise_id} temporairement indisponible (HTTP 503), pytestbdd_stepdef_given_le destinataire de #{invoice_id} est #{enterprise_id}, pytestbdd_stepdef_given_le service PEPPOL configuré en mode &quot;{mode}&quot;, pytestbdd_stepdef_given_le service PEPPOL simulé avec:, pytestbdd_stepdef_given_trace, pytestbdd_stepdef_given_un SML de test lent, pytestbdd_stepdef_given_un timeout configuré à {timeout:d} secondes, pytestbdd_stepdef_given_un utilisateur, pytestbdd_stepdef_given_un utilisateur de la PA #{pa}, pytestbdd_stepdef_given_une facture #{invoice_id} reçue via AS4 depuis une PA distante, pytestbdd_stepdef_then_PEPPOL retourne &quot;{error_code}&quot;, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint Chorus Pro via Pagero, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint de #{pa_id}, pytestbdd_stepdef_then_j'obtiens &quot;{result}&quot;, pytestbdd_stepdef_then_j'obtiens l'URL du SMP &quot;{smp_url}&quot;, pytestbdd_stepdef_then_j'obtiens l'endpoint de la PA responsable, pytestbdd_stepdef_then_j'obtiens le code de retour {code}, pytestbdd_stepdef_then_j'obtiens le statut &quot;{status}&quot;, pytestbdd_stepdef_then_j'obtiens le statut #{status}, pytestbdd_stepdef_then_j'obtiens sur le canal 'healthcheck_resp' le message 'toto', pytestbdd_stepdef_then_j'obtiens sur le canal '{canal}' un message, pytestbdd_stepdef_then_j'obtiens un numéro de tâche, pytestbdd_stepdef_then_j'obtiens une erreur &quot;{error_code}&quot;, pytestbdd_stepdef_then_j'obtiens une erreur DNS &quot;{error}&quot;, pytestbdd_stepdef_then_j'obtiens une erreur HTTP {status_code:d}, pytestbdd_stepdef_then_j'obtiens une réponse DNS valide, pytestbdd_stepdef_then_j'obtiens une réponse SML valide, pytestbdd_stepdef_then_j'obtiens une réponse SMP valide, pytestbdd_stepdef_then_l'adresse de l'endpoint est &quot;{address}&quot;, pytestbdd_stepdef_then_l'endpoint AS4 est &quot;{endpoint}&quot;, pytestbdd_stepdef_then_l'identification par {facon} porte le code &quot;{code}&quot;, pytestbdd_stepdef_then_la destination est &quot;{destination}&quot;, pytestbdd_stepdef_then_la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL, pytestbdd_stepdef_then_la facture est livrée localement à #{enterprise_id}, pytestbdd_stepdef_then_la facture est livrée à #{enterprise_id}, pytestbdd_stepdef_then_la facture est mise en file d'attente pour retry, pytestbdd_stepdef_then_la facture est transmise au PPF, pytestbdd_stepdef_then_la facture est transmise au PPF_1, pytestbdd_stepdef_then_la facture est transmise au service de routage, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4_1, pytestbdd_stepdef_then_la facture est transmise à Chorus Pro, pytestbdd_stepdef_then_la facture est validée, pytestbdd_stepdef_then_la facture n'est PAS transmise au service de routage, pytestbdd_stepdef_then_la facture passe par l'annuaire local, pytestbdd_stepdef_then_la facture passe par le service de validation, pytestbdd_stepdef_then_la première tentative échoue, pytestbdd_stepdef_then_la requête SMP échoue avec HTTP {status_code:d}, pytestbdd_stepdef_then_la réponse SMP est signée, pytestbdd_stepdef_then_la résolution SML réussit, pytestbdd_stepdef_then_la seconde tentative réussit, pytestbdd_stepdef_then_la signature est valide, pytestbdd_stepdef_then_le certificat est au format X.509, pytestbdd_stepdef_then_le certificat est présent et valide, pytestbdd_stepdef_then_le certificat est signé par une autorité PEPPOL valide, pytestbdd_stepdef_then_le certificat n'est pas expiré, pytestbdd_stepdef_then_le certificat n'est pas révoqué, pytestbdd_stepdef_then_le code erreur est &quot;{error_code}&quot;, pytestbdd_stepdef_then_le destinataire #{enterprise_id} est trouvé localement, pytestbdd_stepdef_then_le destinataire #{enterprise_id} n'est pas trouvé localement, pytestbdd_stepdef_then_le hostname SML est &quot;B-{{hash}}.iso6523-actorid-upis.{sml_zone}&quot;, pytestbdd_stepdef_then_le lookup PEPPOL réussit, pytestbdd_stepdef_then_le lookup PEPPOL échoue, pytestbdd_stepdef_then_le message erreur contient &quot;{text}&quot;, pytestbdd_stepdef_then_le process identifier est &quot;{process_id}&quot;, pytestbdd_stepdef_then_le routage échoue définitivement, pytestbdd_stepdef_then_le service de routage consulte PEPPOL, pytestbdd_stepdef_then_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_then_le service de routage ne consulte PAS PEPPOL, pytestbdd_stepdef_then_le signataire est le SMP enregistré, pytestbdd_stepdef_then_le transport profile est &quot;{transport_profile}&quot;, pytestbdd_stepdef_then_les document types supportés incluent:, pytestbdd_stepdef_then_trace, pytestbdd_stepdef_then_un accusé de réception AS4 est envoyé, pytestbdd_stepdef_then_un message d'erreur est publié sur &quot;{channel}&quot;, pytestbdd_stepdef_then_une seconde tentative est programmée après {delay:d} secondes, pytestbdd_stepdef_when_j'appele l'API {verb} {path}, pytestbdd_stepdef_when_j'interroge la tâche, pytestbdd_stepdef_when_j'interroge le SML via DNS, pytestbdd_stepdef_when_j'écoute le canal '{canal}', pytestbdd_stepdef_when_je calcule l'empreinte md5 de &quot;{msg}&quot;, pytestbdd_stepdef_when_je calcule l'empreinte {facon} &quot;{id}&quot;, pytestbdd_stepdef_when_je calcule l'hôte SML pour {facon} &quot;{id}&quot;, pytestbdd_stepdef_when_je définis un contrôle de conformité métier fournisseur, pytestbdd_stepdef_when_je dépose la facture #{invoice_id}, pytestbdd_stepdef_when_je dépose la facture #{invoice} sur #{pa}, pytestbdd_stepdef_when_je dépose pour contrôle la facture @{invoice}, pytestbdd_stepdef_when_je dépose une facture, pytestbdd_stepdef_when_je publie le message '{msg}' sur le canal '{canal}', pytestbdd_stepdef_when_je recherche le participant PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIREN &quot;{siren}&quot;, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIRET &quot;{siret}&quot;, pytestbdd_stepdef_when_je recherche les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère la liste des document types pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_l'adresse de contrôle &quot;{url}&quot;, pytestbdd_stepdef_when_la PA #{pa_id} reçoit la facture #{invoice_id} via AS4, pytestbdd_stepdef_when_la requête DNS prend plus de {timeout:d} secondes, pytestbdd_stepdef_when_le document type est &quot;{doc_type}&quot;, pytestbdd_stepdef_when_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_trace, pytestbdd_stepdef_when_un utilisateur de #{pa_id} dépose la facture #{invoice_id}, pytestbdd_stepdef_when_{retries:d} tentatives échouent, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, user, world&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py:296">file /home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py, line 296
          def scenario_wrapper(request: FixtureRequest, _pytest_bdd_example: dict[str, str]) -&gt; Any:
E       fixture 'world1pac' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pytest_bdd_example, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, auth, author, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, doctest_namespace, event_loop_policy, extra, extras, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, metadata, monkeypatch, pac, peppol_context, peppol_service, pytestbdd_stepdef_given_#{enterprise_id} ne supporte que les factures UBL, pytestbdd_stepdef_given_#{entity_id} accessible via Chorus Pro sur PEPPOL, pytestbdd_stepdef_given_#{pa_id1} et #{pa_id2} enregistrées mutuellement sur PEPPOL, pytestbdd_stepdef_given_l'entité publique #{entity_id} avec le SIRET "{siret}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIREN "{siren}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} avec le SIRET "{siret}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur PEPPOL avec scheme "{scheme}", pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id}, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} enregistrée sur la PA #{pa_id} via PEPPOL, pytestbdd_stepdef_given_l'entreprise #{enterprise_id} non enregistrée sur PEPPOL, pytestbdd_stepdef_given_la PA #{pa_id}, pytestbdd_stepdef_given_la facture #{invoice_id} de #{sender_id} à #{recipient_id}, pytestbdd_stepdef_given_la racine SML "{zone}", pytestbdd_stepdef_given_le SML de test "{sml_zone}", pytestbdd_stepdef_given_le SMP de #{enterprise_id} accessible à "{smp_url}", pytestbdd_stepdef_given_le SMP de #{enterprise_id} disponible après {delay:d} secondes, pytestbdd_stepdef_given_le SMP de #{enterprise_id} définitivement indisponible, pytestbdd_stepdef_given_le SMP de #{enterprise_id} indisponible la première fois, pytestbdd_stepdef_given_le SMP de #{enterprise_id} temporairement indisponible (HTTP 503), pytestbdd_stepdef_given_le destinataire de #{invoice_id} est #{enterprise_id}, pytestbdd_stepdef_given_le service PEPPOL configuré en mode "{mode}", pytestbdd_stepdef_given_le service PEPPOL simulé avec:, pytestbdd_stepdef_given_trace, pytestbdd_stepdef_given_un SML de test lent, pytestbdd_stepdef_given_un timeout configuré à {timeout:d} secondes, pytestbdd_stepdef_given_un utilisateur, pytestbdd_stepdef_given_un utilisateur de la PA #{pa}, pytestbdd_stepdef_given_une facture #{invoice_id} reçue via AS4 depuis une PA distante, pytestbdd_stepdef_then_PEPPOL retourne "{error_code}", pytestbdd_stepdef_then_PEPPOL retourne l'endpoint Chorus Pro via Pagero, pytestbdd_stepdef_then_PEPPOL retourne l'endpoint de #{pa_id}, pytestbdd_stepdef_then_j'obtiens "{result}", pytestbdd_stepdef_then_j'obtiens l'URL du SMP "{smp_url}", pytestbdd_stepdef_then_j'obtiens l'endpoint de la PA responsable, pytestbdd_stepdef_then_j'obtiens le code de retour {code}, pytestbdd_stepdef_then_j'obtiens le statut "{status}", pytestbdd_stepdef_then_j'obtiens le statut #{status}, pytestbdd_stepdef_then_j'obtiens sur le canal 'healthcheck_resp' le message 'toto', pytestbdd_stepdef_then_j'obtiens sur le canal '{canal}' un message, pytestbdd_stepdef_then_j'obtiens un numéro de tâche, pytestbdd_stepdef_then_j'obtiens une erreur "{error_code}", pytestbdd_stepdef_then_j'obtiens une erreur DNS "{error}", pytestbdd_stepdef_then_j'obtiens une erreur HTTP {status_code:d}, pytestbdd_stepdef_then_j'obtiens une réponse DNS valide, pytestbdd_stepdef_then_j'obtiens une réponse SML valide, pytestbdd_stepdef_then_j'obtiens une réponse SMP valide, pytestbdd_stepdef_then_l'adresse de l'endpoint est "{address}", pytestbdd_stepdef_then_l'endpoint AS4 est "{endpoint}", pytestbdd_stepdef_then_l'identification par {facon} porte le code "{code}", pytestbdd_stepdef_then_la destination est "{destination}", pytestbdd_stepdef_then_la facture #{invoice_id} est routée vers #{pa_id} via PEPPOL, pytestbdd_stepdef_then_la facture est livrée localement à #{enterprise_id}, pytestbdd_stepdef_then_la facture est livrée à #{enterprise_id}, pytestbdd_stepdef_then_la facture est mise en file d'attente pour retry, pytestbdd_stepdef_then_la facture est transmise au PPF, pytestbdd_stepdef_then_la facture est transmise au PPF_1, pytestbdd_stepdef_then_la facture est transmise au service de routage, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4, pytestbdd_stepdef_then_la facture est transmise à #{pa_id} via AS4_1, pytestbdd_stepdef_then_la facture est transmise à Chorus Pro, pytestbdd_stepdef_then_la facture est validée, pytestbdd_stepdef_then_la facture n'est PAS transmise au service de routage, pytestbdd_stepdef_then_la facture passe par l'annuaire local, pytestbdd_stepdef_then_la facture passe par le service de validation, pytestbdd_stepdef_then_la première tentative échoue, pytestbdd_stepdef_then_la requête SMP échoue avec HTTP {status_code:d}, pytestbdd_stepdef_then_la réponse SMP est signée, pytestbdd_stepdef_then_la résolution SML réussit, pytestbdd_stepdef_then_la seconde tentative réussit, pytestbdd_stepdef_then_la signature est valide, pytestbdd_stepdef_then_le certificat est au format X.509, pytestbdd_stepdef_then_le certificat est présent et valide, pytestbdd_stepdef_then_le certificat est signé par une autorité PEPPOL valide, pytestbdd_stepdef_then_le certificat n'est pas expiré, pytestbdd_stepdef_then_le certificat n'est pas révoqué, pytestbdd_stepdef_then_le code erreur est "{error_code}", pytestbdd_stepdef_then_le destinataire #{enterprise_id} est trouvé localement, pytestbdd_stepdef_then_le destinataire #{enterprise_id} n'est pas trouvé localement, pytestbdd_stepdef_then_le hostname SML est "B-{{hash}}.iso6523-actorid-upis.{sml_zone}", pytestbdd_stepdef_then_le lookup PEPPOL réussit, pytestbdd_stepdef_then_le lookup PEPPOL échoue, pytestbdd_stepdef_then_le message erreur contient "{text}", pytestbdd_stepdef_then_le process identifier est "{process_id}", pytestbdd_stepdef_then_le routage échoue définitivement, pytestbdd_stepdef_then_le service de routage consulte PEPPOL, pytestbdd_stepdef_then_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_then_le service de routage ne consulte PAS PEPPOL, pytestbdd_stepdef_then_le signataire est le SMP enregistré, pytestbdd_stepdef_then_le transport profile est "{transport_profile}", pytestbdd_stepdef_then_les document types supportés incluent:, pytestbdd_stepdef_then_trace, pytestbdd_stepdef_then_un accusé de réception AS4 est envoyé, pytestbdd_stepdef_then_un message d'erreur est publié sur "{channel}", pytestbdd_stepdef_then_une seconde tentative est programmée après {delay:d} secondes, pytestbdd_stepdef_when_j'appele l'API {verb} {path}, pytestbdd_stepdef_when_j'interroge la tâche, pytestbdd_stepdef_when_j'interroge le SML via DNS, pytestbdd_stepdef_when_j'écoute le canal '{canal}', pytestbdd_stepdef_when_je calcule l'empreinte md5 de "{msg}", pytestbdd_stepdef_when_je calcule l'empreinte {facon} "{id}", pytestbdd_stepdef_when_je calcule l'hôte SML pour {facon} "{id}", pytestbdd_stepdef_when_je définis un contrôle de conformité métier fournisseur, pytestbdd_stepdef_when_je dépose la facture #{invoice_id}, pytestbdd_stepdef_when_je dépose la facture #{invoice} sur #{pa}, pytestbdd_stepdef_when_je dépose pour contrôle la facture @{invoice}, pytestbdd_stepdef_when_je dépose une facture, pytestbdd_stepdef_when_je publie le message '{msg}' sur le canal '{canal}', pytestbdd_stepdef_when_je recherche le participant PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIREN "{siren}", pytestbdd_stepdef_when_je recherche le participant PEPPOL pour le SIRET "{siret}", pytestbdd_stepdef_when_je recherche les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère la liste des document types pour #{enterprise_id}, pytestbdd_stepdef_when_je récupère les métadonnées SMP pour #{enterprise_id}, pytestbdd_stepdef_when_l'adresse de contrôle "{url}", pytestbdd_stepdef_when_la PA #{pa_id} reçoit la facture #{invoice_id} via AS4, pytestbdd_stepdef_when_la requête DNS prend plus de {timeout:d} secondes, pytestbdd_stepdef_when_le document type est "{doc_type}", pytestbdd_stepdef_when_le service de routage consulte PEPPOL pour #{enterprise_id}, pytestbdd_stepdef_when_trace, pytestbdd_stepdef_when_un utilisateur de #{pa_id} dépose la facture #{invoice_id}, pytestbdd_stepdef_when_{retries:d} tentatives échouent, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, user, world
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/home/philippe/src/PA_Communautaire/packages/pac-bdd/.venv/lib/python3.13/site-packages/pytest_bdd/scenario.py:296</failure></testcase><testcase classname="test_scenario" name="test_controle_format_facturx" time="0.000"><failure message="NotImplementedError">fixturefunc = &lt;function control_invoice at 0x763203f691c0&gt;, request = &lt;FixtureRequest for &lt;Function test_controle_format_facturx&gt;&gt;, kwargs = {}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @when(
        parsers.parse("je dépose pour contrôle la facture @{invoice}"),
    )
    def control_invoice():
&gt;       raise NotImplementedError()
E       NotImplementedError

src/pac_bdd/tobeimplemented.py:26: NotImplementedError</failure></testcase><testcase classname="test_scenario" name="test_démarrage_dun_serveur_nats" time="0.002"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un serveur NATS disponible&quot;. Line 18 in scenario &quot;Démarrage d'un serveur NATS&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un serveur NATS disponible". Line 18 in scenario "Démarrage d'un serveur NATS" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_connexion_dun_broker_au_serveur_nats" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un serveur NATS disponible&quot;. Line 22 in scenario &quot;Connexion d'un broker au serveur NATS&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un serveur NATS disponible". Line 22 in scenario "Connexion d'un broker au serveur NATS" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_démarrage_de_plusieurs_pa" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;2 PA démarrées&quot;. Line 31 in scenario &quot;Démarrage de plusieurs PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "2 PA démarrées". Line 31 in scenario "Démarrage de plusieurs PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/service_lifecycle.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_démarrage_dun_service_nats_local" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service NATS local&quot;. Line 20 in scenario &quot;Démarrage d'un service NATS local&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service NATS local". Line 20 in scenario "Démarrage d'un service NATS local" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_connexion_à_un_service_nats_distant" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service NATS local comme référence&quot;. Line 26 in scenario &quot;Connexion à un service NATS distant&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service NATS local comme référence". Line 26 in scenario "Connexion à un service NATS distant" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_démarrage_dun_service_peppol_mock" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service Peppol en mode mock&quot;. Line 32 in scenario &quot;Démarrage d'un service Peppol mock&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service Peppol en mode mock". Line 32 in scenario "Démarrage d'un service Peppol mock" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_configuration_des_réponses_peppol_mock" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service Peppol en mode mock&quot;. Line 37 in scenario &quot;Configuration des réponses Peppol mock&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service Peppol en mode mock". Line 37 in scenario "Configuration des réponses Peppol mock" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_recherche_peppol_dune_entreprise_non_enregistrée" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service Peppol en mode mock&quot;. Line 44 in scenario &quot;Recherche Peppol d'une entreprise non enregistrée&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service Peppol en mode mock". Line 44 in scenario "Recherche Peppol d'une entreprise non enregistrée" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_démarrage_dun_service_pa" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service PA&quot;. Line 50 in scenario &quot;Démarrage d'un service PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service PA". Line 50 in scenario "Démarrage d'un service PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_création_dun_monde_avec_1_pa" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 1 PA&quot;. Line 60 in scenario &quot;Création d'un monde avec 1 PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 1 PA". Line 60 in scenario "Création d'un monde avec 1 PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_création_dun_monde_avec_2_pa" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA&quot;. Line 67 in scenario &quot;Création d'un monde avec 2 PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA". Line 67 in scenario "Création d'un monde avec 2 PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_création_dun_monde_avec_4_pa" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 4 PA&quot;. Line 73 in scenario &quot;Création d'un monde avec 4 PA&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 4 PA". Line 73 in scenario "Création d'un monde avec 4 PA" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_les_pa_partagent_le_même_service_nats" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA&quot;. Line 81 in scenario &quot;Les PA partagent le même service NATS&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA". Line 81 in scenario "Les PA partagent le même service NATS" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_les_pa_ont_des_ports_api_distincts" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 3 PA&quot;. Line 86 in scenario &quot;Les PA ont des ports API distincts&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 3 PA". Line 86 in scenario "Les PA ont des ports API distincts" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_toutes_les_pa_répondent_au_healthcheck" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA&quot;. Line 94 in scenario &quot;Toutes les PA répondent au healthcheck&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA". Line 94 in scenario "Toutes les PA répondent au healthcheck" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_information_du_monde" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA&quot;. Line 103 in scenario &quot;Information du monde&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA". Line 103 in scenario "Information du monde" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_arrêt_propre_du_monde" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA démarré&quot;. Line 114 in scenario &quot;Arrêt propre du monde&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA démarré". Line 114 in scenario "Arrêt propre du monde" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_monde_avec_nats_externe" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service NATS local comme référence&quot;. Line 125 in scenario &quot;Monde avec NATS externe&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service NATS local comme référence". Line 125 in scenario "Monde avec NATS externe" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_monde_avec_peppol_personnalisé" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un service Peppol en mode mock comme référence&quot;. Line 131 in scenario &quot;Monde avec Peppol personnalisé&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un service Peppol en mode mock comme référence". Line 131 in scenario "Monde avec Peppol personnalisé" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_dépôt_de_facture_entre_2_pa_via_peppol" time="0.000"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given &quot;un monde avec 2 PA&quot;. Line 140 in scenario &quot;Dépôt de facture entre 2 PA via Peppol&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Given "un monde avec 2 PA". Line 140 in scenario "Dépôt de facture entre 2 PA via Peppol" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/world.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_healthcheck_message" time="0.007"><failure message="AssertionError: Expected 'mock' to be called once. Called 0 times.">fixturefunc = &lt;function esb_sub_msg at 0x763203f68860&gt;, request = &lt;FixtureRequest for &lt;Function test_healthcheck_message&gt;&gt;, kwargs = {'world': WorldContextOld()}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src/pac_bdd/esb.py:14: in wrapper
    return asyncio.run(fn(*args, **kwargs))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:195: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/runners.py:118: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/asyncio/base_events.py:725: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
src/pac_bdd/esb.py:72: in esb_sub_msg
    handle_all.mock.assert_called_once_with("toto")
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;MagicMock id='129957188497632'&gt;, args = ('toto',), kwargs = {}, msg = "Expected 'mock' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to be called once. Called 0 times.

../../../../.local/share/uv/python/cpython-3.13.2-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:988: AssertionError</failure></testcase><testcase classname="test_scenario" name="test_canal_pingpong" time="0.003"><failure message="pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Then &quot;j'obtiens le message 'hello' sur le canal 'pong'&quot;. Line 10 in scenario &quot;Canal ping/pong&quot; in the feature &quot;/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/esb.feature&quot;">E   pytest_bdd.exceptions.StepDefinitionNotFoundError: Step definition is not found: Then "j'obtiens le message 'hello' sur le canal 'pong'". Line 10 in scenario "Canal ping/pong" in the feature "/home/philippe/src/PA_Communautaire/docs/briques/02-esb-central/esb.feature"
All traceback entries are hidden. Pass `--full-trace` to see hidden and internal frames.</failure></testcase><testcase classname="test_scenario" name="test_pa" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">fixturefunc = &lt;function pa_defined at 0x763203e05940&gt;, request = &lt;FixtureRequest for &lt;Function test_pa&gt;&gt;
kwargs = {'pa_id': 'pa1', 'peppol_context': PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None), pa_id = 'pa1'

    @given(parsers.parse("la PA #{pa_id}"))
    def pa_defined(peppol_context, pa_id: str):
        """Définit une PA."""
&gt;       peppol_context["pas"][pa_id] = {
        ^^^^^^^^^^^^^^^^^^^^^
            "id": pa_id,
            "enterprises": [],
            "endpoint": f"https://ap.{pa_id}.fr/as4",
        }
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:303: TypeError</failure></testcase><testcase classname="test_scenario" name="test_résolution_sml_réussie_pour_un_participant_enregistré" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_résolution_sml_réussie_pour_un_participant_enregistré&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_résolution_sml_échouée__participant_non_enregistré" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_résolution_sml_échouée__participant_non_enregistré&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_récupération_métadonnées_smp_réussie" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_récupération_métadonnées_smp_réussie&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_smp_ne_supporte_pas_le_document_type_demandé" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_smp_ne_supporte_pas_le_document_type_demandé&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_lookup_peppol_complet_réussi_par_siren" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_lookup_peppol_complet_réussi_par_siren&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_lookup_peppol_complet_réussi_par_siret" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_lookup_peppol_complet_réussi_par_siret&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_lookup_peppol_échoué__participant_introuvable" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_lookup_peppol_échoué__participant_introuvable&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_routage_facture_vers_pa_distante_via_peppol" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_routage_facture_vers_pa_distante_via_peppol&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_routage_facture__destinataire_local_pas_de_lookup_peppol" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_routage_facture__destinataire_local_pas_de_lookup_peppol&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_routage_facture__fallback_vers_ppf" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_routage_facture__fallback_vers_ppf&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_validation_du_certificat_peppol" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_validation_du_certificat_peppol&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_vérification_de_la_signature_smp" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_vérification_de_la_signature_smp&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_vérification_des_document_types_supportés" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_vérification_des_document_types_supportés&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_timeout_lors_du_lookup_sml" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_timeout_lors_du_lookup_sml&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_smp_temporairement_indisponible" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_smp_temporairement_indisponible&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_retry_automatique_après_échec_temporaire" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_retry_automatique_après_échec_temporaire&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_échec_définitif_après_plusieurs_retries" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_échec_définitif_après_plusieurs_retries&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_communication_bidirectionnelle_entre_2_pa" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_communication_bidirectionnelle_entre_2_pa&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_réception_dune_facture_via_as4_depuis_une_pa_distante" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_réception_dune_facture_via_as4_depuis_une_pa_distante&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_facture_b2g_via_chorus_pro_peppol" time="0.001"><failure message="TypeError: 'PeppolContext' object is not subscriptable">self = &lt;FixtureRequest for &lt;Function test_facture_b2g_via_chorus_pro_peppol&gt;&gt;, argname = 'peppol_service'

    def getfixturevalue(self, argname: str) -&gt; Any:
        """Dynamically run a named fixture function.
    
        Declaring fixtures via function argument is recommended where possible.
        But if you can only decide whether to use another fixture at test
        setup time, you may use this function to retrieve it inside a fixture
        or test function body.
    
        This method can be used during the test setup phase or the test run
        phase, but during the test teardown phase a fixture's value may not
        be available.
    
        :param argname:
            The fixture name.
        :raises pytest.FixtureLookupError:
            If the given fixture could not be found.
        """
        # Note that in addition to the use case described in the docstring,
        # getfixturevalue() is also called by pytest itself during item and fixture
        # setup to evaluate the fixtures that are requested statically
        # (using function parameters, autouse, etc).
    
&gt;       fixturedef = self._get_active_fixturedef(argname)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:640: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1128: in execute
    result = ihook.pytest_fixture_setup(fixturedef=self, request=request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:730: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:1196: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: in call_fixture_func
    fixture_result = fixturefunc(**kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result=None)

    @pytest.fixture
    def peppol_service(peppol_context) -&gt; PeppolLookupService:
        """Service PEPPOL configuré pour les tests."""
    
        def mock_dns_resolver(hostname: str) -&gt; Optional[str]:
            """Résolveur DNS mock pour les tests."""
            return peppol_context["dns_responses"].get(hostname)
    
        service = PeppolLookupService(
&gt;           environment=peppol_context["environment"],
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            dns_resolver=mock_dns_resolver,
        )
E       TypeError: 'PeppolContext' object is not subscriptable

src/pac_bdd/peppol.py:99: TypeError</failure></testcase><testcase classname="test_scenario" name="test_xxxxx" time="0.003" /><testcase classname="test_scenario" name="test_md5" time="0.001"><failure message="AssertionError">fixturefunc = &lt;function check_result at 0x763203ff3ba0&gt;, request = &lt;FixtureRequest for &lt;Function test_md5&gt;&gt;
kwargs = {'peppol_context': PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result='b881aaeff8eeaed7190491ccdeaa42fc'), 'result': '6c2675d749449f2c8af1216fd866bb54'}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

peppol_context = PeppolContext(sml_zone='acc.edelivery.tech.ec.europa.eu', enterprise_id=None, siren=None, siret=None, result='b881aaeff8eeaed7190491ccdeaa42fc')
result = '6c2675d749449f2c8af1216fd866bb54'

    @then(parsers.parse('''j'obtiens "{result}"'''))
    def check_result(
        peppol_context: PeppolContext,
        result: str,
    ):
        """étape générique pour tester tout résultat"""
        if peppol_context.result != result:
            print(f"result: {peppol_context.result}")
            print(f"expecting: {result}")
&gt;       assert peppol_context.result == result
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError

src/pac_bdd/peppol.py:124: AssertionError</failure></testcase><testcase classname="test_scenario" name="test_identification_france" time="0.001" /><testcase classname="test_scenario" name="test_empreinte_participant" time="0.001" /><testcase classname="test_scenario" name="test_hôte_sml" time="0.001" /><testcase classname="test_scenario" name="test_rejet_dolibarr" time="0.000"><failure message="NotImplementedError">fixturefunc = &lt;function compliance_rule_set at 0x763203f69760&gt;, request = &lt;FixtureRequest for &lt;Function test_rejet_dolibarr&gt;&gt;, kwargs = {}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @when("je définis un contrôle de conformité métier fournisseur")
    def compliance_rule_set():
&gt;       raise NotImplementedError()
E       NotImplementedError

src/pac_bdd/tobeimplemented.py:41: NotImplementedError</failure></testcase><testcase classname="test_scenario" name="test_facture_rejetée" time="0.001"><failure message="NotImplementedError">fixturefunc = &lt;function submit_invoice_simple at 0x763203f68e00&gt;, request = &lt;FixtureRequest for &lt;Function test_facture_rejetée&gt;&gt;, kwargs = {}

    def call_fixture_func(
        fixturefunc: _FixtureFunc[FixtureValue], request: FixtureRequest, kwargs
    ) -&gt; FixtureValue:
        if inspect.isgeneratorfunction(fixturefunc):
            fixturefunc = cast(Callable[..., Generator[FixtureValue]], fixturefunc)
            generator = fixturefunc(**kwargs)
            try:
                fixture_result = next(generator)
            except StopIteration:
                raise ValueError(f"{request.fixturename} did not yield a value") from None
            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
            request.addfinalizer(finalizer)
        else:
            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)
&gt;           fixture_result = fixturefunc(**kwargs)
                             ^^^^^^^^^^^^^^^^^^^^^

.venv/lib/python3.13/site-packages/_pytest/fixtures.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    @when("je dépose une facture")
    def submit_invoice_simple():
        # POST /
&gt;       raise NotImplementedError()
E       NotImplementedError

src/pac_bdd/tobeimplemented.py:13: NotImplementedError</failure></testcase></testsuite></testsuites>